#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass ADT
\begin_preamble
\usepackage{tikz}
\usetikzlibrary{shapes,arrows}
\end_preamble
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip smallskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
ADT - Automatic Differentiation via TAPENADE Utility : Users Manual
\end_layout

\begin_layout Standard
ADT is a command line application that allows you to produce Pascal units
 or C++ classes containing automatically differentiated code through the
 use of the TAPENADE automatic differentiation tool.
 
\end_layout

\begin_layout Title
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Chapter
Building ADT
\end_layout

\begin_layout Section
Prerequisites
\end_layout

\begin_layout Standard
Before building ADT and the demonstration R library you need to ensure that
 you have TAPENADE installed on your machine.
 TAPENADE is available from: 
\end_layout

\begin_layout SourceCode
http://www-sop.inria.fr/tropics/tapenade/downloading.html
\end_layout

\begin_layout Standard
You can read more about TAPENADE and automatic differentiation here:
\end_layout

\begin_layout SourceCode
http://www-sop.inria.fr/tropics/tapenade.html
\end_layout

\begin_layout Standard
The TAPENADE bin folder needs to be in the PATH environment variable so
 that it can be run without specifying a fully qualified path to the file.
 On Linux  systems a good place to install TAPENADE is in 
\emph on
/usr/share
\emph default
 (eg.
 
\emph on
/usr/share/tapenade3.10
\emph default
).
  On Windows systems install under the Program Files folder (eg.
 
\emph on
C:
\backslash
Program Files
\backslash
tapenade3.10
\emph default
).
 
\end_layout

\begin_layout Standard
To build ADT, on Linux distributions you must have gcc, flex, bison and
 the automake tool set installed and on Windows you must have either Visual
 Studio 2005 (or higher installed) or cygwin with gcc and the automake toolset
 installed and flex and bison.
 Flex and Bison can be found here: 
\end_layout

\begin_layout SourceCode
http://www.gnu.org/software/flex
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout SourceCode
http://www.gnu.org/software/bison
\end_layout

\begin_layout Standard
When installing Flex and Bison on Windows ensure that the path to the install
 location does not contain spaces as Bison doesn't handle paths with spaces
 correctly on the Windows build.
 The default install location is typically 
\emph on
C:
\backslash
Program Files
\backslash
GnuWin32
\emph default
.
 Change it to 
\emph on
C:
\backslash
GnuWin32
\emph default
.
 The bin folder will also need to be in the system path so add
\emph on
 C:
\backslash
GnuWin32
\emph default
 to the system path using the Advanced System Settings in the control panel
 system section.
 
\end_layout

\begin_layout Standard
In order to run the example project you will need to have R installed.
 R can be obtained from: 
\end_layout

\begin_layout SourceCode
http://www.r-project.org
\end_layout

\begin_layout Standard
Further to these requirements, should you wish to build and run the Pascal
 example then you will also need to install lazarus and ensure that the
 Free Pascal compiler bin folder is in the PATH environment variable.
 Lazarus is available from here: 
\end_layout

\begin_layout SourceCode
http://www.lazarus.freepascal.org
\end_layout

\begin_layout Section
Building ADT on Linux
\end_layout

\begin_layout Standard
Run the configure script to generated the necessary makefiles.
 That is, in the root folder for adt (the folder where the source package
 is installed - for example: 
\emph on
/usr/src/adt-1.03
\emph default
), run the following in a command shell: 
\end_layout

\begin_layout SourceCode
./configure 
\end_layout

\begin_layout Standard
On completion run:
\end_layout

\begin_layout SourceCode
make clean
\end_layout

\begin_layout Standard
and, 
\end_layout

\begin_layout SourceCode
make
\end_layout

\begin_layout Standard
and, 
\end_layout

\begin_layout SourceCode
sudo make install
\end_layout

\begin_layout Standard
If you have compile errors there are a number of possible reasons.
 Firstly, do you have the necessary tools installed (gcc, flex, bison, TAPENADE
 and R)? If you do, is TAPENADE and R in the search PATH and is R installed
 in a different location to where the configure script expects it to be?
 By default, configure assumes the R include files to be located in, 
\end_layout

\begin_layout SourceCode
/usr/share/R/include
\end_layout

\begin_layout Standard
and the R shared library to be located in, 
\end_layout

\begin_layout SourceCode
/usr/lib/R/lib
\end_layout

\begin_layout Standard
If your locations are different to these then you will have to run configure
 with options specifying the correct paths and the re-run make and sudo
 make install.
 That is, 
\end_layout

\begin_layout SourceCode
./configure --with-R-include-path={path to R include folder}
\backslash

\end_layout

\begin_layout SourceCode
            --with-R-lib-path={path to R lib folder}
\end_layout

\begin_layout Standard
For further information you can run, 
\end_layout

\begin_layout SourceCode
./configure --help 
\end_layout

\begin_layout Standard
When compiled without error you should have the static libraries 
\shape italic
ADlib
\shape default
 and 
\shape italic
ADlibErr
\shape default
 installed in 
\emph on
/usr/local/lib
\emph default
 and adt installed in 
\emph on
/usr/local/bin
\emph default
.
 Running, 
\end_layout

\begin_layout SourceCode
adt
\end_layout

\begin_layout Standard
should display the help text for ADT.
 
\end_layout

\begin_layout Section
Building ADT on Windows
\end_layout

\begin_layout Standard
Building ADT on Windows can be done in one of two ways.
 Firstly, by using a CygWin or MinGW install with Automake utilities installed,
 adt can be built using the same procedure as for building under Linux.
 
\end_layout

\begin_layout Standard
Alternatively, VC solution and workspace files are included in the 
\emph on
objs
\emph default
 folder and may be used to build adt using Visual C++.
 If building via Visual C++, it is necessary to install flex and bison and
 have them in the system path.
 
\end_layout

\begin_layout Standard
A Windows compatible Flex can be found here: 
\end_layout

\begin_layout SourceCode
http://gnuwin32.sourceforge.net/packages/flex.htm 
\end_layout

\begin_layout Standard
A Windows compatible Bison can be found here: 
\end_layout

\begin_layout SourceCode
http://gnuwin32.sourceforge.net/packages/bison.htm 
\end_layout

\begin_layout Standard
When building with Visual C++ the executable will be in either the 
\emph on
debug
\emph default
 or 
\emph on
release
\emph default
 folder under the 
\emph on
objs
\emph default
 folder, depending on whether you choose to build a debug or release version.
 When the build is complete running,
\end_layout

\begin_layout SourceCode
./objs/debug/adt
\end_layout

\begin_layout Standard
or,
\end_layout

\begin_layout SourceCode
./objs/release/adt
\end_layout

\begin_layout Standard
should display the help text for ADT.
 
\end_layout

\begin_layout Section
Running ADT 
\end_layout

\begin_layout Standard
Before you run Adt you must ensure that you have TAPENADE installed and
 running on your machine.
 Once TAPENADE is installed and can be run from a shell command prompt,
 you can run adt in the following manner.
 
\end_layout

\begin_layout SourceCode
adt <makefile1>[ <makefile2> ...] 
\end_layout

\begin_layout Standard
The makefile adheres to the format detailed below.
 Required user data is enclosed in <>.
 Optional data is enclosed in [].
 
\end_layout

\begin_layout Standard
Filenames and paths only need to be quoted when whitespace occurs in the
 name.
 Any extra arguments passed to TAPENADE using the USER parameter must be
 quoted in a single string.
 Single line comments begin with // and free formating of the makefile is
 allowed provided the syntax is preserved.
 
\end_layout

\begin_layout Standard
The source code classes whose methods are being differentiated must be derrived
 from the tuseful class and can only use the array types provided by that
 class.
 Any other non-scalar types are not allowed in differentiated code.
 
\end_layout

\begin_layout SourceCode
AD 
\end_layout

\begin_layout SourceCode
BEGIN
\end_layout

\begin_layout SourceCode
  [SWITCHES: switch1,switch2,…,switchN;] //Optional
\end_layout

\begin_layout SourceCode
  [BLACKBOX: File1,File2,…,FileN;] // Optional
\end_layout

\begin_layout SourceCode
  PATHS: <path 1[,path 2, ...
 ,path n]>; 
\end_layout

\begin_layout SourceCode
  SOURCE FILES: <include file 1[, include file 2, ...
 ,include file n]>; 
\end_layout

\begin_layout SourceCode
  WORKING DIRECTORY: <path to working directory>;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  // language dependent file defining source code macro substitutions and
\end_layout

\begin_layout SourceCode
  // array types - Required.
 
\end_layout

\begin_layout SourceCode
  PASCAL OPTIONS FILE: pascal_macros.txt; 
\end_layout

\begin_layout SourceCode
  // language dependent file defining source code macro substitutions and
\end_layout

\begin_layout SourceCode
  // array types - Required.
 
\end_layout

\begin_layout SourceCode
  CPP OPTIONS FILE: cpp_macros.txt; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  // file defining fortran functions needed to do the dfferentiation - Required.
 
\end_layout

\begin_layout SourceCode
  FORTRAN INCLUDE FILES: stdlib.f; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS <DifferentiatedClass_1> (<ClassBeingDifferentiated_1>) 
\end_layout

\begin_layout SourceCode
  SOURCE FILE: <class source file> 
\end_layout

\begin_layout SourceCode
  OUTPUT FILE: <differentiated class destination file> 
\end_layout

\begin_layout SourceCode
  BEGIN 
\end_layout

\begin_layout SourceCode
    FUNCTION=<function_1_to_differentiate> // The function to differentiate
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> // Specify the output variables 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var> // Specify the variable to differentiate with respect
 to 
\end_layout

\begin_layout SourceCode
      // Tapenade differentiation modes 
\end_layout

\begin_layout SourceCode
      // ------------------------------ 
\end_layout

\begin_layout SourceCode
      // f = forward or tangent mode 
\end_layout

\begin_layout SourceCode
      // r = reverse mode 
\end_layout

\begin_layout SourceCode
      // m = multi-directional tangent mode 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>; // Additional command line
 
\end_layout

\begin_layout SourceCode
      // arguments to pass to Tapenade - these must be bracketed by quotes
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    FUNCTION=<function_n_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>; 
\end_layout

\begin_layout SourceCode
  END
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  .
 
\end_layout

\begin_layout SourceCode
  .
 
\end_layout

\begin_layout SourceCode
  .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS <DifferentiatedClass_n> (<ClassBeingDifferentiated_n>) 
\end_layout

\begin_layout SourceCode
  SOURCE FILE: <class source file> 
\end_layout

\begin_layout SourceCode
  OUTPUT FILE: <differentiated class destination file> 
\end_layout

\begin_layout SourceCode
  BEGIN 
\end_layout

\begin_layout SourceCode
    FUNCTION=<function_1_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    FUNCTION=<function_n_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>; 
\end_layout

\begin_layout SourceCode
  END
\end_layout

\begin_layout SourceCode
END
\end_layout

\begin_layout Standard
Note that in the case of C++ code generation the OUTPUT FILE entry is replaced
 by OUTPUT FILES and both the destination header and source file names must
 be specified.
 That is,
\end_layout

\begin_layout LyX-Code
  CLASS <DifferentiatedClass_n> (<ClassBeingDifferentiated_n>)
\begin_inset Newline newline
\end_inset

  SOURCE FILE: <class source file>
\begin_inset Newline newline
\end_inset

  OUTPUT FILES: <differentiated class destination header file>
\begin_inset Newline newline
\end_inset

                <differentiated class destination source file>
\begin_inset Newline newline
\end_inset

  BEGIN
\begin_inset Newline newline
\end_inset

    FUNCTION=<function_1_to_differentiate>
\begin_inset Newline newline
\end_inset

    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]>
\begin_inset Newline newline
\end_inset

    VAR=<diff_wrt_var>
\begin_inset Newline newline
\end_inset

    MODE=<Tapenade differentiation mode>
\begin_inset Newline newline
\end_inset

    USER=<'extra tapenade command line args'>;
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

    .
\begin_inset Newline newline
\end_inset

    .
\begin_inset Newline newline
\end_inset

    .
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

    FUNCTION=<function_n_to_differentiate>
\begin_inset Newline newline
\end_inset

    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]>
\begin_inset Newline newline
\end_inset

    VAR=<diff_wrt_var>
\begin_inset Newline newline
\end_inset

    MODE=<Tapenade differentiation mode>
\begin_inset Newline newline
\end_inset

    USER=<'extra tapenade command line args'>;
\begin_inset Newline newline
\end_inset

  END
\begin_inset Newline newline
\end_inset

END 
\end_layout

\begin_layout Chapter
Using ADT
\end_layout

\begin_layout Section
An R auto-differentiation example
\end_layout

\begin_layout Standard
A complete auto-differentiation sample application can be found in the folder
 
\emph on
sample
\emph default
.
 This folder contains three sub folders : 
\emph on
ArrayTest, common
\emph default
, 
\emph on
include
\emph default
 and 
\emph on
Rosenbrock
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
ArrayTest
\emph default
 contains a test harness application built using 
\shape italic
ADLib
\shape default
 and the automation provided by ADT.
 
\end_layout

\begin_layout Standard

\emph on
common
\emph default
 contains useful Pascal source code.
 
\end_layout

\begin_layout Standard

\emph on
include
\emph default
 contains files needed by ADT to correctly function.
 
\end_layout

\begin_layout Standard

\emph on
Rosenbrock
\emph default
 contains files needed to build and run the example R dynamic library, which
 in this case, is a simple minimisation of the Rosenbrock minimisation problem
 for testing the convergence of minimisers.
 
\end_layout

\begin_layout Standard
If all compiled without error when building ADT, then you should already
 have a complete shared library for this example.
 To run the example change directories to the 
\emph on
Rosenbrock
\emph default
 folder.
 For example, 
\end_layout

\begin_layout SourceCode
cd sample/Rosenbrock
\end_layout

\begin_layout Standard
now start R with, 
\end_layout

\begin_layout SourceCode
R
\end_layout

\begin_layout Standard
This assumes that R is in the executable search PATH.
 If it isn't then you will need to fully qualify the command.
 
\end_layout

\begin_layout Standard
In the R session enter the following command, 
\end_layout

\begin_layout SourceCode
source('Rosenbrock.R', print.eval=TRUE) 
\end_layout

\begin_layout Standard
On doing so and after a minute or so you should see some results displayed
 similar to the following: 
\end_layout

\begin_layout SourceCode
[1] "Comparison of minimisation run times and performance for different
 "
\end_layout

\begin_layout SourceCode
[2] "implementations of the Rosenbrock minimisation problem with "     
  
\end_layout

\begin_layout SourceCode
[3] "150 parameters.
 Minimisation performed using nlminb.
 "              
\end_layout

\begin_layout SourceCode
                                               case objective    RMS.error
\end_layout

\begin_layout SourceCode
1                                       All R based         0 7.307681e-12
\end_layout

\begin_layout SourceCode
2                                     C++ objective         0 1.505906e-09
\end_layout

\begin_layout SourceCode
3                       C++ objective - transposing         0 1.505906e-09
\end_layout

\begin_layout SourceCode
4                        C++ objective and gradient         0 5.016338e-12
\end_layout

\begin_layout SourceCode
5          C++ objective and gradient - transposing         0 5.016338e-12
\end_layout

\begin_layout SourceCode
6               C++ objective, gradient and hessian         0 0.000000e+00
\end_layout

\begin_layout SourceCode
7 C++ objective, gradient and hessian - transposing         0 0.000000e+00
\end_layout

\begin_layout SourceCode
  convergence time.taken iterations fn.evaluations grad.evaluations
\end_layout

\begin_layout SourceCode
1           0      43.12        501            818            83418
\end_layout

\begin_layout SourceCode
2           1       0.73        321            539            68260
\end_layout

\begin_layout SourceCode
3           1       0.76        321            539            68260
\end_layout

\begin_layout SourceCode
4           1       0.65        496            856              496
\end_layout

\begin_layout SourceCode
5           1       0.66        496            856              496
\end_layout

\begin_layout SourceCode
6           0       0.43         18             29               19
\end_layout

\begin_layout SourceCode
7           0       9.17        255            347              256
\end_layout

\begin_layout SourceCode
                message
\end_layout

\begin_layout SourceCode
1     X-convergence (3) 
\end_layout

\begin_layout SourceCode
2 false convergence (8) 
\end_layout

\begin_layout SourceCode
3 false convergence (8) 
\end_layout

\begin_layout SourceCode
4 false convergence (8) 
\end_layout

\begin_layout SourceCode
5 false convergence (8) 
\end_layout

\begin_layout SourceCode
6     X-convergence (3) 
\end_layout

\begin_layout SourceCode
7     X-convergence (3) 
\end_layout

\begin_layout Standard
This shows the comparative performance of various minimisations of the same
 Rosenbrock function, implemented in R, in C++ and with an without algorithmical
ly differentiated gradient and hessian.
 Having access to machine precision gradient and hessian has a significant
 effect on minimiser performance.
 In particular, it is interesting to note that with machine precision gradient
 and hessian 
\emph on
nlminb
\emph default
 was able to find the solution exactly and in the shortest amount of time.
 
\end_layout

\begin_layout Standard
Study the example code, the adt makefile and the Tapenade documentation
 to understand how it works and how to solve your own AD problems.
\end_layout

\begin_layout Section
The example in more detail
\end_layout

\begin_layout Standard
A Rosenbrock function is a non-convex function of know minimum used to test
 the convergence performance of minimisation algorithms and was introduce
 by Howard H.
 Rosenbrock in 1960.
 For the two dimensional form the global minimum is situated in a long parabolic
 shaped valley.
 To find the valley is easy but finding the minimum is significantly harder.
 
\end_layout

\begin_layout Standard
The two dimensional form is defined as,
\end_layout

\begin_layout Standard
\begin_inset Formula $f\left(x,y\right)=$
\end_inset


\begin_inset Formula $\left(1-x\right)^{2}+100\left(y-x^{2}\right)^{2}$
\end_inset


\end_layout

\begin_layout Standard
and has a global mimimum at 
\begin_inset Formula $\left(x,y\right)=\left(1,1\right)$
\end_inset

of 
\begin_inset Formula $f\left(x,y\right)=0$
\end_inset

.
\end_layout

\begin_layout Standard
The multi-dimensional form is defined as,
\end_layout

\begin_layout Standard
\begin_inset Formula $f\left(X\right)=f\left(x_{1},x_{2},...,x_{N}\right)=\begin{array}{c}
{\scriptstyle N/2}\\
\sum\\
{\scriptstyle i=1}
\end{array}$
\end_inset


\begin_inset Formula $\left[100\left(x_{2i-1}^{2}-x_{2i}\right)^{2}+\left(x_{2i-1}-1\right)^{2}\right]$
\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $N$
\end_inset

 is even.
 This is the form we shall use to test the convergence of the 
\emph on
nlminb()
\emph default
 minimiser in R.
 
\end_layout

\begin_layout Standard
To implement a minimiser test we need to first implement the above function
 which we shall do in C++.
 ADT only supports parsing a subset of the C++ language.
 The limitations on C++ use are as follows:
\end_layout

\begin_layout Itemize
Only intrinsic types and the array types defined in 
\emph on
AdtArrays.hpp
\emph default
 may be used in your code.
\end_layout

\begin_layout Itemize
Classes cannot be used in code that is to be automatically differentiated.
 
\end_layout

\begin_layout Itemize
Local variable declarations must be in one block at the beginning of a function
 definition (much like C syntax) and combined declaration - initialisation
 is not allowed.
\end_layout

\begin_layout Itemize
Use of case to distinguish between variables is not allowed.
 This is because the AD part carried out by Tapenade is in Fortran code
 which is case insensitive.
 Any discrimination by case is lost in the translation to Fortran.
\end_layout

\begin_layout Itemize
Any function to be automatically differentiated must be a public method
 of a class publically derived from 
\emph on
AdtArray
\emph default
.
\end_layout

\begin_layout Itemize
Function overloading for differentiated code is not allowed (that is providing
 multiple implementations of the same function that differ only by the function
 argument list).
\end_layout

\begin_layout Itemize
Meta data is required in the form of comments to instruct ADT about the
 size of arrays and for the automatic creation of R interface code (see
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ADT-Automatic-R"

\end_inset

 for more details).
\end_layout

\begin_layout Standard
With that in mind we implement a simple class called 
\emph on
MinRosenbrock
\emph default
 (in files 
\emph on
Rosenbrock.hpp
\emph default
 and 
\emph on
Rosenbrock.cpp
\emph default
) as shown below.
 
\end_layout

\begin_layout SourceCode
#include <adtarrays.hpp>
\end_layout

\begin_layout SourceCode
#include "adtR.hpp"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
// -------------------------------------------------------------
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
class MinRosenbrock : public AdtArrays
\end_layout

\begin_layout SourceCode
{ 
\end_layout

\begin_layout SourceCode
  protected:
\end_layout

\begin_layout SourceCode
   /* AD_LIBNAME Rosenbrock */
\end_layout

\begin_layout SourceCode
   /* AD_ALIAS Rb=D_MinRosenbrock */
\end_layout

\begin_layout SourceCode
   /* AUTOINIT */
\end_layout

\begin_layout SourceCode
   int     N;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
#include "Rb_array_plans.hpp"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
public:
\end_layout

\begin_layout SourceCode
   MinRosenbrock( 
\end_layout

\begin_layout SourceCode
#include "Rb_constructor_args.hpp"
\end_layout

\begin_layout SourceCode
   );
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
#include "Rb_decl_lib_interface_methods.hpp"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  double  rosenbrock(const ARRAY_1D X/*N*/);
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
Firstly, it includes the files 
\emph on
adtarrays.hpp
\emph default
 (needed for the array support) and 
\emph on
adtR.hpp
\emph default
 (needed for the R interface support).
 Secondly, it declares the class 
\emph on
MinRosenbrock
\emph default
, which is derived from 
\emph on
AdtArrays
\emph default
, and declares and implements the method 
\emph on
rosenbrock()
\emph default
 and the attribute 
\emph on
N
\emph default
, both used to implement our N order rosenbrock function.
 Thirdly, it has a bunch of comments to instruct ADT how to process the
 file.
 
\end_layout

\begin_layout Standard
The comments,
\end_layout

\begin_layout SourceCode
/* AD_LIBNAME Rosenbrock */
\end_layout

\begin_layout SourceCode
/* AD_ALIAS Rb=D_MinRosenbrock */
\end_layout

\begin_layout SourceCode
/* AUTOINIT */
\end_layout

\begin_layout Standard
instruct ADT that the library name to be generated is Rosenbrock (
\shape italic
AD_LIBNAME
\shape default
 command), instruct ADT to generate R interface code for this class (
\emph on
AD_ALIAS
\emph default
 command) and automatically initialise the N attribute (
\emph on
AUTOINIT
\emph default
 command).
 The comment in,
\end_layout

\begin_layout SourceCode
double  rosenbrock(const ARRAY_1D X/*N*/);
\end_layout

\begin_layout Standard
instructs ADT that the array 
\emph on
X
\emph default
 has a dimension of 
\emph on
N
\emph default
.
 The other include file directives are includes inserted to include the
 automatically generated R interface and intialisation code.
 
\end_layout

\begin_layout Standard
In 
\emph on
Rosenbrock.cpp
\emph default
 the class is implemented as is shown below.
\end_layout

\begin_layout SourceCode
#include "Rosenbrock.hpp"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
// -------------------------------------------------------------
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
MinRosenbrock::MinRosenbrock( 
\end_layout

\begin_layout SourceCode
#include "Rb_constructor_args.hpp"
\end_layout

\begin_layout SourceCode
)
\end_layout

\begin_layout SourceCode
{   
\end_layout

\begin_layout SourceCode
  #include "Rb_constructor_locals.hpp"
\end_layout

\begin_layout SourceCode
  #include "Rb_constructor_scalars_phase_1.hpp"
\end_layout

\begin_layout SourceCode
  #include "Rb_constructor_arrays_phase_1.hpp"
\end_layout

\begin_layout SourceCode
  #include "Rb_array_plans_init.hpp"
\end_layout

\begin_layout SourceCode
}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
// -------------------------------------------------------------
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
double MinRosenbrock::rosenbrock(const ARRAY_1D X/*N*/)
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  int cn;
\end_layout

\begin_layout SourceCode
  double dSum;
\end_layout

\begin_layout SourceCode
  double p1,p2,f1,f2;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  dSum = 0.0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  for (cn = 1 ; cn <= N / 2 ; cn++)
\end_layout

\begin_layout SourceCode
  {
\end_layout

\begin_layout SourceCode
    p1 = X[2 * cn - 1];
\end_layout

\begin_layout SourceCode
    p2 = X[2 * cn];
\end_layout

\begin_layout SourceCode
    f1 = (p1 * p1 - p2);
\end_layout

\begin_layout SourceCode
    f1 = 100 * f1 * f1;
\end_layout

\begin_layout SourceCode
    f2 = (p1 - 1.0);
\end_layout

\begin_layout SourceCode
    f2 = f2 * f2;
\end_layout

\begin_layout SourceCode
    dSum += f1 + f2;
\end_layout

\begin_layout SourceCode
  }
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  return (dSum); 
\end_layout

\begin_layout SourceCode
} 
\end_layout

\begin_layout Standard
Note again, the presence of include directives for the automatically generated
 code.
 From inspection it should be seen that the method 
\emph on
rosenbrock()
\emph default
 does indeed implement the Rosenbrock function as defined earlier.
 
\end_layout

\begin_layout Standard
Having defined the method and its containing class an ADT make file is required
 to instruct ADT on which files to process and which functions to differentiate.
 This is the purpose of the file 
\emph on
Rosenbrock.mk
\emph default
 shown below (see section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ADT-Make-Files"

\end_inset

 for more information on ADT make files).
\end_layout

\begin_layout SourceCode
AD BEGIN
\end_layout

\begin_layout SourceCode
  PATHS: "../include","../common", "../../src/ADLib";
\end_layout

\begin_layout SourceCode
  WORKING DIRECTORY: "./work/";
\end_layout

\begin_layout SourceCode
  CPP OPTIONS FILE: cpp_macros.txt;
\end_layout

\begin_layout SourceCode
  PASCAL OPTIONS FILE: pascal_macros.txt;
\end_layout

\begin_layout SourceCode
  FORTRAN INCLUDE FILES: stdlib.f;
\end_layout

\begin_layout SourceCode
  CLASS D_MinRosenbrock(MinRosenbrock) 
\end_layout

\begin_layout SourceCode
    SOURCE FILE: Rosenbrock.cpp 
\end_layout

\begin_layout SourceCode
    OUTPUT FILES: d_Rosenbrock.cpp d_Rosenbrock.hpp
\end_layout

\begin_layout SourceCode
  BEGIN
\end_layout

\begin_layout SourceCode
    FUNCTION=rosenbrock OUTVAR=rosenbrock VAR=X MODE=r;
\end_layout

\begin_layout SourceCode
    FUNCTION=ROSENBROCK_BX OUTVAR=xb1_x VAR=X MODE=f;
\end_layout

\begin_layout SourceCode
  END
\end_layout

\begin_layout SourceCode
  CLASS DR_MinRosenbrock(R_MinRosenbrock) 
\end_layout

\begin_layout SourceCode
    SOURCE FILE: R_Rosenbrock.cpp 
\end_layout

\begin_layout SourceCode
    OUTPUT FILES: dR_Rosenbrock.cpp dR_Rosenbrock.hpp
\end_layout

\begin_layout SourceCode
  BEGIN
\end_layout

\begin_layout SourceCode
  END
\end_layout

\begin_layout SourceCode
END
\end_layout

\begin_layout Standard
Each class entry instructs ADT to build a new class derived from the one
 listed and apply the given AD operations to the specified 
\emph on
FUNCTIONs
\emph default
.
 In this case that class is 
\emph on
MinRosenbrock
\emph default
 and the method to differentiate is 
\emph on
rosenbrock
\emph default
 (to give the gradient function).
 It is differentiated in reverse mode (
\emph on
r
\emph default
) to obtain the gradient vector rather than forward mode (
\emph on
f
\emph default
) which would only give a directional derivative.
 As a hessian implementation is also required we also take the directional
 derivative of 
\emph on
ROSENBROCK_BX
\emph default
, the gradient function that resulted from the previous AD operation.
 
\end_layout

\begin_layout Standard
The hessian function must be hand written using the directional second derivativ
e.
 These functions are implemented in the class 
\emph on
R_MinRosenbrock
\emph default
 (found in 
\emph on
R_Rosenbrock.cpp
\emph default
 and 
\emph on
R_Rosenbrock.hpp
\emph default
).
 Since ADT will create R code to instantiate the differentiated version
 of the class, a null differentiation step is required so that the instantiated
 class will be a parent of 
\emph on
R_MinRosenbrock
\emph default
, hence the final null AD step in the makefile.
 It is possible to leave that step out but doing so would mean that the
 R interface code would need to be hand written, which is a tedious and
 error prone process.
 
\end_layout

\begin_layout Standard
ADT also automatically creates R interface code for all public methods of
 every AD class and getter and setter methods to access automation initialised
 attributes of those classes.
\end_layout

\begin_layout Section
An R auto-differentiation example - Pascal version
\end_layout

\begin_layout Standard
If you wish to code in Pascal rather than C++ a Pascal sample of the same
 problem is also included.
 
\end_layout

\begin_layout Standard
Before you can run the Pascal version you must first build the shared library.
 Under Windows run the batch file 
\emph on
build_lib.bat
\emph default
.
 Under Linux distributions run 
\emph on
build_lib.sh
\emph default
.
 
\end_layout

\begin_layout Standard
To run the Pascal example change directories to the 
\emph on
Rosenbrock
\emph default
 folder.
 For example, 
\end_layout

\begin_layout SourceCode
cd sample/Rosenbrock 
\end_layout

\begin_layout Standard
now start R with, 
\end_layout

\begin_layout SourceCode
R 
\end_layout

\begin_layout Standard
This assumes that R is in the executable search PATH.
 If it isn't then you will need to fully qualify the command.
 
\end_layout

\begin_layout Standard
In the R session enter the following command, 
\end_layout

\begin_layout SourceCode
source('RosenbrockPas.R', print.eval=TRUE) 
\end_layout

\begin_layout Standard
On doing so and after a minute or so you should see some results displayed
 similar to the following: 
\end_layout

\begin_layout SourceCode
[1] "Comparison of minimisation run times and performance for different
 "
\end_layout

\begin_layout SourceCode
[2] "implementations of the Rosenbrock minimisation problem with "     
  
\end_layout

\begin_layout SourceCode
[3] "150 parameters.
 Minimisation performed using nlminb.
 "              
\end_layout

\begin_layout SourceCode
                                                  case objective    RMS.error
\end_layout

\begin_layout SourceCode
1                                          All R based         0 7.307681e-12
\end_layout

\begin_layout SourceCode
2                                     Pascal objective         0 2.354987e-11
\end_layout

\begin_layout SourceCode
3                       Pascal objective - transposing         0 2.354987e-11
\end_layout

\begin_layout SourceCode
4                        Pascal objective and gradient         0 1.473745e-11
\end_layout

\begin_layout SourceCode
5          Pascal objective and gradient - transposing         0 1.473745e-11
\end_layout

\begin_layout SourceCode
6               Pascal objective, gradient and hessian         0 0.000000e+00
\end_layout

\begin_layout SourceCode
7 Pascal objective, gradient and hessian - transposing         0 5.933984e-14
\end_layout

\begin_layout SourceCode
  convergence time.taken iterations fn.evaluations grad.evaluations
\end_layout

\begin_layout SourceCode
1           0      42.62        501            818            83418
\end_layout

\begin_layout SourceCode
2           1       1.47        574            938            98685
\end_layout

\begin_layout SourceCode
3           1       1.58        574            938            98685
\end_layout

\begin_layout SourceCode
4           1       0.67        494            824              494
\end_layout

\begin_layout SourceCode
5           1       0.70        494            824              494
\end_layout

\begin_layout SourceCode
6           0       0.49         18             29               19
\end_layout

\begin_layout SourceCode
7           0       9.91        257            355              258
\end_layout

\begin_layout SourceCode
                message
\end_layout

\begin_layout SourceCode
1     X-convergence (3)
\end_layout

\begin_layout SourceCode
2 false convergence (8)
\end_layout

\begin_layout SourceCode
3 false convergence (8)
\end_layout

\begin_layout SourceCode
4 false convergence (8)
\end_layout

\begin_layout SourceCode
5 false convergence (8)
\end_layout

\begin_layout SourceCode
6     X-convergence (3)
\end_layout

\begin_layout SourceCode
7     X-convergence (3)
\end_layout

\begin_layout Standard
This shows the comparative performance of various minimisations of the same
 Rosenbrock function, implemented in R, in Pascal and with an without algorithmi
cally differentiated gradient and hessian.
 Having access to machine precision gradient and hessian has a significant
 effect on minimiser performance.
 In particular, it is interesting to note that with machine precision gradient
 and hessian 
\emph on
nlminb
\emph default
 was able to find the solution exactly and in the shortest amount of time.
 
\end_layout

\begin_layout Chapter
ADT Reference
\end_layout

\begin_layout Section
TAPENADE Primer
\end_layout

\begin_layout Standard
TAPENADE is both a command line and a web based automatic / algorithmic
 differentiation engine that takes source code in Fortran and differentiates
 the specified functions to produce modified Fortran code which calculating
 the differentials.
 This is loosely termed as AD by code translation as opposed to AD by operator
 overloading.
 The latter exploits the language features of object oriented languages
 like C++ to implement AD and generally produces code that is typically
 not as fast as that through the code translation approach.
 The added efficiencies available in the latter stem from the ability to
 be able to optimise out common subexpressions so that they are evaluated
 only once, which is something very difficult to achieve automatically in
 the operator overloading approach.
 ADT makes use of the command line version of TAPENADE to synthesise differentia
ls.
\end_layout

\begin_layout Standard
For reasons of efficiency TAPENADE does not produce differentials directly.
 Instead it produces them in two common flavours, 
\emph on
Tangent
\emph default
 codes (Jacobian times Vector) or 
\emph on
Forward
\emph default
 mode and 
\emph on
Adjoint
\emph default
 codes (Transposed Jacobian times Vector) or 
\emph on
Reverse
\emph default
 mode.
 Several strategies are employed in TAPENADE to produce efficient codes.
 TAPENADE calculates differentials of scalar functions.
 Should the output of a function be a vector quantity then TAPENADE interperates
 it as a system of scalar equations and differentiates each individually,
 returning a vector quantity of the same dimension to represent the result.
 
\end_layout

\begin_layout Subsection
Forward Mode
\end_layout

\begin_layout Standard
Forward or Tangent mode calculates the sensitivities of the output variables
 to the input variables.
 For each output variable TAPENADE creates a new output variable with the
 same name but with 
\emph on
d
\emph default
 appended to it (d for 
\begin_inset Quotes eld
\end_inset

dot
\begin_inset Quotes erd
\end_inset

).
 Similarly for each input variable it creates a new input variable with
 the same name but with 
\emph on
d
\emph default
 appended to it.
 These input variables are multiplied with the corresponding differential
 in a dot product with the Jacobian.
 To illustrate, here is a simple contrived example.
 Our Fortran function source code is,
\end_layout

\begin_layout SourceCode
DOUBLE PRECISION FUNCTION trig(x, y)
\end_layout

\begin_layout SourceCode
  INTENT (IN) x, y
\end_layout

\begin_layout SourceCode
  trig = cos(3 * x) + sin(y / 5)
\end_layout

\begin_layout SourceCode
  RETURN 
\end_layout

\begin_layout SourceCode
END
\end_layout

\begin_layout Standard
Running it through TAPENADE specifying trig as the head routine and asking
 for a tangent mode output, TAPENADE responds with,
\end_layout

\begin_layout SourceCode
!        Generated by TAPENADE     (INRIA, Tropics team) 
\end_layout

\begin_layout SourceCode
!  Tapenade 3.7 (r4888) - 28 May 2013 10:47 
\end_layout

\begin_layout SourceCode
! 
\end_layout

\begin_layout SourceCode
!  Differentiation of trig in forward (tangent) mode: 
\end_layout

\begin_layout SourceCode
!   variations   of useful results: trig 
\end_layout

\begin_layout SourceCode
!   with respect to varying inputs: x y 
\end_layout

\begin_layout SourceCode
!   RW status of diff variables: x:in y:in trig:out 
\end_layout

\begin_layout SourceCode
DOUBLE PRECISION FUNCTION TRIG_D(x, xd, y, yd, trig)
\end_layout

\begin_layout SourceCode
  IMPLICIT NONE
\end_layout

\begin_layout SourceCode
  REAL :: x
\end_layout

\begin_layout SourceCode
  REAL :: y
\end_layout

\begin_layout SourceCode
  INTENT(IN) x, y
\end_layout

\begin_layout SourceCode
  REAL :: xd
\end_layout

\begin_layout SourceCode
  REAL :: yd
\end_layout

\begin_layout SourceCode
  INTENT(IN) xd, yd
\end_layout

\begin_layout SourceCode
  DOUBLE PRECISION :: trig
\end_layout

\begin_layout SourceCode
  INTRINSIC COS
\end_layout

\begin_layout SourceCode
  INTRINSIC SIN
\end_layout

\begin_layout SourceCode
  trig_d = yd*COS(y/5)/5 - 3*xd*SIN(3*x)
\end_layout

\begin_layout SourceCode
  trig = COS(3*x) + SIN(y/5)
\end_layout

\begin_layout SourceCode
  RETURN
\end_layout

\begin_layout SourceCode
END FUNCTION TRIG_D
\end_layout

\begin_layout Standard
Studying the code you can see that the differential output 
\emph on
trig_d
\emph default
 is the dot product of the Jacobian with the vector [
\emph on
xd, yd
\emph default
].
 In addition to returning this sensitivity result, it also returns the result
 of the original function evaluated at the same point in the new variable
 
\emph on
trig
\emph default
.
 This is the way TAPENADE behaves when used in tangent / foward mode.
 
\end_layout

\begin_layout Standard
From the above it should be apparent that we can obtain the partial differential
s for the function by specifying the correct values for 
\emph on
xd
\emph default
 and 
\emph on
yd
\emph default
.
 For example,
\end_layout

\begin_layout SourceCode
x_dot = TRIG_D(x, 1, y, 0, trig)
\end_layout

\begin_layout Standard
will return the partial differential of trig at 
\emph on
x,y
\emph default
 with respect to 
\emph on
x
\emph default
 and,
\end_layout

\begin_layout SourceCode
y_dot = TRIG_D(x, 0, y, 1, trig)
\end_layout

\begin_layout Standard
will return the partial differential of trig at 
\emph on
x,y
\emph default
 with respect to 
\emph on
y
\emph default
.
\end_layout

\begin_layout Subsection
Reverse Mode
\end_layout

\begin_layout Standard
Reverse or Adjoint mode calculates the scaled gradient vector for the output
 variables with respect to the dependent input variables.
 For each input variable TAPENADE creates a new output variable with the
 same name but with 
\emph on
b
\emph default
 appended to it (b for 
\begin_inset Quotes eld
\end_inset

bar
\begin_inset Quotes erd
\end_inset

).
 Similarly for each output variable it creates a new input variable with
 the same name but with 
\emph on
b
\emph default
 appended to it.
 Applying TAPENADE to the same source code as the Forward Mode example but
 requesting a adjoint / reverse mode output, TAPENADE gives,
\end_layout

\begin_layout SourceCode
!        Generated by TAPENADE     (INRIA, Tropics team)
\end_layout

\begin_layout SourceCode
!  Tapenade 3.7 (r4888) - 28 May 2013 10:47
\end_layout

\begin_layout SourceCode
!
\end_layout

\begin_layout SourceCode
!  Differentiation of trig in reverse (adjoint) mode:
\end_layout

\begin_layout SourceCode
!   gradient     of useful results: x y trig
\end_layout

\begin_layout SourceCode
!   with respect to varying inputs: x y
\end_layout

\begin_layout SourceCode
!   RW status of diff variables: x:incr y:incr trig:in-killed 
\end_layout

\begin_layout SourceCode
SUBROUTINE TRIG_B(x, xb, y, yb, trigb)
\end_layout

\begin_layout SourceCode
  IMPLICIT NONE   
\end_layout

\begin_layout SourceCode
  REAL :: x
\end_layout

\begin_layout SourceCode
  REAL :: y
\end_layout

\begin_layout SourceCode
  INTENT(IN) x, y
\end_layout

\begin_layout SourceCode
  DOUBLE PRECISION :: trigb
\end_layout

\begin_layout SourceCode
  DOUBLE PRECISION :: trig
\end_layout

\begin_layout SourceCode
  REAL :: xb
\end_layout

\begin_layout SourceCode
  REAL :: yb
\end_layout

\begin_layout SourceCode
  INTRINSIC COS
\end_layout

\begin_layout SourceCode
  INTRINSIC SIN
\end_layout

\begin_layout SourceCode
  xb = xb - SIN(3*x)*3*trigb
\end_layout

\begin_layout SourceCode
  yb = yb + COS(y/5)*trigb/5
\end_layout

\begin_layout SourceCode
END SUBROUTINE TRIG_B
\end_layout

\begin_layout Standard
from which it is clear that 
\emph on
TRIG_B
\emph default
 returns the gradient result for the function when 
\emph on
trigb
\emph default
 is set to one and 
\emph on
xb
\emph default
 and 
\emph on
yb
\emph default
 are intialised to zero before calling 
\emph on
TRIG_B
\emph default
.
 Note that the rules governing the introduction of 
\shape italic
xb
\shape default
, 
\shape italic
yb
\shape default
 and 
\shape italic
trigb
\shape default
 and their processing may look odd but is done this way to facilitate the
 chaining of operations through application of the chain rule to obtain
 the adjoint differential of a given outer function.
 
\end_layout

\begin_layout Standard
Reverse mode is an efficient means of finding the gradient (partial differential
s with respect to all dependent inputs) but it requires a tape / stack to
 store partial results on the reverse parse.
 The simplicity of the previous example meant no stack was required but
 in general one is and TAPENADE will insert PUSHes and POPs to save and
 restore partial results.
 Should you wish to apply second order differentiation to a reverse mode
 output the PUSHes and POPs must be removed and replaced with arrays.
 ADT does exactly that.
 
\end_layout

\begin_layout Standard
PUSHing and POPing everything to a stack can consume vast amounts of memory
 for complex problems, which in turn can make computation time baloon out
 as memory resources are exhausted.
 To combat this problem TAPENADE uses checkpointing, which in laymans terms,
 approximately means breaking the problem up into smaller pieces to reduce
 the stack requirements.
 TAPENADE does checkpointing on a function / subroutine call basis so that
 the stack requirements of function calls within a function are isolated
 from the enclosing function.
 
\end_layout

\begin_layout Subsection
ADT Naming Convention
\end_layout

\begin_layout Standard
The naming convention used for the creation of new variables and functions
 by TAPENADE is an extension of the TAPENADE default behaviour.
 Since the primary aim of ADT is to easily allow higher order differentiation,
 even when using reverse mode, we need to create new variables in a manner
 that will not result in name clashes with previous output.
 As such, the naming convention in ADT includes an iteration number that
 corresponds to the number of the operation in the list of FUNCTIONs to
 be AD'ed within the ADT makefile and the variables we are differentiating
 with respect to.
 
\end_layout

\begin_layout Standard
The variable and function naming conforms to the following templates.
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
FUNCTION
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Forward Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{function name}_D{dependent variables}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reverse Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{function name}_B{dependent variables}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="3" columns="2">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
VARIABLE
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Forward Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{variable name}d{iteration}_{dependent variables}
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Reverse Mode
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
{variable name}b{iteration}_{dependent variables}
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout Standard
As an example, consider the makefile from the demonstration project in ADT
 as shown below,
\end_layout

\begin_layout SourceCode
AD BEGIN
\end_layout

\begin_layout SourceCode
  PATHS: "../include","../common", "../../src/ADLib";
\end_layout

\begin_layout SourceCode
  WORKING DIRECTORY: "./work/";
\end_layout

\begin_layout SourceCode
  CPP OPTIONS FILE: cpp_macros.txt;
\end_layout

\begin_layout SourceCode
  PASCAL OPTIONS FILE: pascal_macros.txt;
\end_layout

\begin_layout SourceCode
  FORTRAN INCLUDE FILES: stdlib.f;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS D_MinRosenbrock(MinRosenbrock) 
\end_layout

\begin_layout SourceCode
    SOURCE FILE: Rosenbrock.cpp 
\end_layout

\begin_layout SourceCode
    OUTPUT FILES: d_Rosenbrock.cpp d_Rosenbrock.hpp
\end_layout

\begin_layout SourceCode
  BEGIN
\end_layout

\begin_layout SourceCode
    FUNCTION=rosenbrock OUTVAR=rosenbrock VAR=X MODE=r;
\end_layout

\begin_layout SourceCode
    FUNCTION=ROSENBROCK_BX OUTVAR=xb1_x VAR=X MODE=f;
\end_layout

\begin_layout SourceCode
  END
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS DR_MinRosenbrock(R_MinRosenbrock) 
\end_layout

\begin_layout SourceCode
    SOURCE FILE: R_Rosenbrock.cpp 
\end_layout

\begin_layout SourceCode
    OUTPUT FILES: dR_Rosenbrock.cpp dR_Rosenbrock.hpp
\end_layout

\begin_layout SourceCode
  BEGIN
\end_layout

\begin_layout SourceCode
  END
\end_layout

\begin_layout SourceCode
END
\end_layout

\begin_layout Standard
The first AD operation is reverse mode differentiation with respect to 
\emph on
X
\emph default
 of the function 
\shape italic
rosenbrock
\shape default
.
 Therefore TAPENADE produces the differentiated function 
\emph on
ROSENBROCK_BX
\emph default
 with the output gradient variable 
\emph on
xb1_x
\emph default
 and the input scaling value 
\emph on
rosenbrockb1_x
\emph default
 because the dependent variable is 
\emph on
x
\emph default
 and the iteration number is 1.
 The second AD operation is forward mode differentiation with respect to
 
\emph on
x
\emph default
 of 
\emph on
ab1_x
\emph default
 of 
\emph on
ROSENBROCK_BX
\emph default
 which yields the function 
\emph on
ROSENBROCK_BX_DX
\emph default
 with output variable
\emph on
 xb1_xd2_x
\emph default
 and input variable 
\emph on
xd2_x
\emph default
 because the dependent variable is 
\emph on
x
\emph default
 and the iteration number is 2.
 
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ADT-Make-Files"

\end_inset

ADT Make Files
\end_layout

\begin_layout Subsection
Structure
\end_layout

\begin_layout Standard
The text within < > is user supplied data, the text within [ ] is optional,
 the remainder is necessary text required to satisfy the make file grammar.
\end_layout

\begin_layout SourceCode
AD 
\end_layout

\begin_layout SourceCode
BEGIN
\end_layout

\begin_layout SourceCode
  [SWITCHES: switch1,switch2,…,switchN;] //Optional
\end_layout

\begin_layout SourceCode
  [BLACKBOX: File1,File2,…,FileN;] // Optional
\end_layout

\begin_layout SourceCode
  PATHS: <path 1[,path 2, ...
 ,path n]>; 
\end_layout

\begin_layout SourceCode
  [SOURCE FILES: <include file 1[, include file 2, ...
 ,include file n]>;] 
\end_layout

\begin_layout SourceCode
  WORKING DIRECTORY: <path to working directory>;
\end_layout

\begin_layout SourceCode
  PASCAL OPTIONS FILE: <pascal options file>; 
\end_layout

\begin_layout SourceCode
  CPP OPTIONS FILE: <C++ options file>; 
\end_layout

\begin_layout SourceCode
  FORTRAN INCLUDE FILES: <fortran include file>
\end_layout

\begin_layout SourceCode
  [SWITCHES <switch 1,switch 2, ...
 ,switch n>]; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS <DifferentiatedClass_1> (<ClassBeingDifferentiated_1>) 
\end_layout

\begin_layout SourceCode
  SOURCE FILE: <class source file> 
\end_layout

\begin_layout SourceCode
  OUTPUT FILE: <differentiated class destination file> 
\end_layout

\begin_layout SourceCode
  BEGIN 
\end_layout

\begin_layout SourceCode
    [BOUNDS CHECK fn1, fn2,…,fnN;] //Optional
\end_layout

\begin_layout SourceCode
    FUNCTION=<function_1_to_differentiate>
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]>
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var_1[,diff_wrt_var_2,...,diff_wrt_var_n]>
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade diffMake File erentiation mode>
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>
\end_layout

\begin_layout SourceCode
    [PRAGMAS=<'Pragma options text'>];
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    FUNCTION=<function_n_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var_1[,diff_wrt_var_2,...,diff_wrt_var_n]> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>
\end_layout

\begin_layout SourceCode
    [PRAGMAS=<'Pragma options text'>]; 
\end_layout

\begin_layout SourceCode
  END
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  .
 
\end_layout

\begin_layout SourceCode
  .
 
\end_layout

\begin_layout SourceCode
  .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  CLASS <DifferentiatedClass_n> (<ClassBeingDifferentiated_n>) 
\end_layout

\begin_layout SourceCode
  SOURCE FILE: <class source file> 
\end_layout

\begin_layout SourceCode
  OUTPUT FILE: <differentiated class destination file> 
\end_layout

\begin_layout SourceCode
  BEGIN 
\end_layout

\begin_layout SourceCode
    [BOUNDS CHECK fn1, fn2,…,fnN;] //Optional
\end_layout

\begin_layout SourceCode
    FUNCTION=<function_1_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var_1[,diff_wrt_var_2,...,diff_wrt_var_n]> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>
\end_layout

\begin_layout SourceCode
    [PRAGMAS=<'Pragma options text'>]; 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
 
\end_layout

\begin_layout SourceCode
    .
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
    FUNCTION=<function_n_to_differentiate> 
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]> 
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var_1[,diff_wrt_var_2,...,diff_wrt_var_n]> 
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode> 
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>
\end_layout

\begin_layout SourceCode
    [PRAGMAS=<'Pragma options text'>]; 
\end_layout

\begin_layout SourceCode
  END
\end_layout

\begin_layout SourceCode
END
\end_layout

\begin_layout Subsection
Incremental Compilation
\end_layout

\begin_layout Standard
As the number of AD operations and AD classes grow, the time taken to generate
 or compile the AD code grows too.
 To minimise the compilation time during the developmental phase of creating
 a library with ADT, ADT includes an incremental compilation mechanism whereby
 it only re-compiles what it thinks it has to based on a dependency checking
 protocol.
 That protocol takes the source file locations and dates and the operations
 carried out on each class and class methods as an indicator of whether
 re-compilation is necessary.
\end_layout

\begin_layout Standard
If any of the source files, working directory, pascal and C++ options files,
 fortran include files and switches change then the entire project is re-built.
 If the class file changes then the entire class and any subsequent classes
 are re-built.
 The implicit assumption in the design is that any CLASSes appearing in
 the make after this one depend on it, so a change in the first one invalidates
 the remainder.
 The individual AD operations defined in each of the FUNCTION entries are
 checked for a change.
 If no change is detected then the cached build from a previous build is
 used.
 If a change is detected then the AD operations are re-envoked and everything
 that follows is as well.
 In this way, adding new functions one at a time will only result in a compilati
on and AD operation step for the added function, the remainder is cached.
 
\end_layout

\begin_layout Standard
The dependency information used to check if a re-build is required is stored
 in a file with 
\emph on
.dch
\emph default
 extension, the name corresponding to the name of the make file less the
 file extension.
 Therefore, to force a full re-compile in the case where you suspect incremental
 compilation as a problem, you can simply delete the 
\emph on
.dch
\emph default
 file to bring about that outcome.
\end_layout

\begin_layout Subsection
Entries in Detail
\end_layout

\begin_layout Subsubsection
PATHS
\end_layout

\begin_layout SourceCode
PATHS: <path 1[,path 2, ...
 ,path n]>;
\end_layout

\begin_layout Standard
The PATHS entry specifies the folder paths to be used when searching for
 the source files referenced in the make file.
 
\end_layout

\begin_layout Subsubsection
SOURCE FILES
\end_layout

\begin_layout SourceCode
[SOURCE FILES: <include file 1[, include file 2, ...
 ,include file n]>;] 
\end_layout

\begin_layout Standard
The SOURCE FILES entry names any additional source files needed to carry
 out automatic differentiation of functions specified in the CLASS sections.
 This generally means the source files containing any code being called
 by the function being differentiated that does not reside in the same source
 file as the function itself.
 You should only reference files containing differentiable code here.
 The source files named must be accessible through one of the paths specified
 in PATHS.
 If your project has no such external file dependencies then the SOURCE
 FILES entry can be completely omitted.
 
\end_layout

\begin_layout Subsubsection
WORKING DIRECTORY
\end_layout

\begin_layout SourceCode
WORKING DIRECTORY: <path to working directory>;
\end_layout

\begin_layout Standard
The WORKING DIRECTORY entry specifies the PATH to the folder in which ADT
 puts working files, which are intermediate files created to carry out the
 automatic differentiation operations requested.
 Having access to these working files is of particular use when trying to
 debug the automatic differentiation process.
 TAPENADE can sometimes create incorrect code and when this happens it is
 necessary to study the inputs and outputs of TAPENADE to determine the
 cause of the problem and remedy it.
 
\end_layout

\begin_layout Subsubsection
PASCAL OPTIONS FILE
\end_layout

\begin_layout SourceCode
PASCAL OPTIONS FILE: <PASCAL options file>; 
\end_layout

\begin_layout Standard
The PASCAL OPTIONS FILE entry names the file containing options controlling
 the interpretation and translation of Pascal code into FORTRAN and back
 again.
 You will typically use the pascal_macros.txt supplied with ADT and provide
 a path to it.
 That is,
\end_layout

\begin_layout SourceCode
PASCAL OPTIONS FILE: pascal_macros.txt; 
\end_layout

\begin_layout Subsubsection
CPP OPTIONS FILE
\end_layout

\begin_layout SourceCode
CPP OPTIONS FILE: <C++ options file>; 
\end_layout

\begin_layout Standard
The CPP OPTIONS FILE entry names the file containing options controlling
 the interpretation and translation of C++ code into FORTRAN and back again.
 You will typically use the cpp_macros.txt supplied with ADT and provide
 a path to it.
 That is,
\end_layout

\begin_layout SourceCode
CPP OPTIONS FILE: cpp_macros.txt; 
\end_layout

\begin_layout Subsubsection
FORTRAN INCLUDE FILES
\end_layout

\begin_layout SourceCode
FORTRAN INCLUDE FILES: <include file 1[, include file 2, ...
 ,include file n]>; 
\end_layout

\begin_layout Standard
The FORTRAN INCLUDE FILES entry names any FORTRAN source files needed to
 carry out automatic differentiation of functions specified in the CLASS
 sections.
 This is provided to give an opportunity to introduce function stubs for
 black box routines.
 You will typically use the stdlib.f file supplied with ADT and provide a
 path to it.
 That is,
\end_layout

\begin_layout SourceCode
FORTRAN INCLUDE FILES: stdlib.f;
\end_layout

\begin_layout Subsubsection
SWITCHES
\end_layout

\begin_layout SourceCode
[SWITCHES <switch 1,switch 2, ...
 ,switch n>];
\end_layout

\begin_layout Standard
The SWITCHES entry lists any control switches to alter the normal behaviour
 of ADT in processing the make file.
 Currently the following switches are defined.
\end_layout

\begin_layout Description
BoundsCheck Enables the bounds checking of all functions defined in the
 parent class and the AD result class.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BOUNDS-CHECK"

\end_inset

 for more information on bounds checking.
\end_layout

\begin_layout Description
WithoutStackSubstitution Disables the replacement of PUSH and POP calls
 with arrays.
 This is principally for debugging ADT behaviour.
\end_layout

\begin_layout Description
ThrowException Enables the throwing of an exception on bounds check failures.
 If not defined no exception is thrown but the error is reported.
 In an R context the R stop() function is called.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:BLACKBOX"

\end_inset

BLACKBOX
\end_layout

\begin_layout SourceCode
[BLACKBOX: <black box file 1[, black box file 2, ...
 ,black box file n]>;] 
\end_layout

\begin_layout Standard
The BLACKBOX entry names any additional black box definition files to be
 passed to Tapenande when carrying out algorithmic differentiation operations.
 These files conform to the syntax for black box definitions in ADT (see
 section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BLACKBOX-and-D/D"

\end_inset

) and are compiled and translated into the more complex form required by
 TAPENADE.
 All black box definitions are combined to form a single black box definition
 file that is passed to TAPENADE through the 
\family typewriter
-ext
\family default
 command lin option.
\end_layout

\begin_layout Subsubsection
CLASS
\end_layout

\begin_layout SourceCode
CLASS <DifferentiatedClass> (<ClassBeingDifferentiated>) 
\end_layout

\begin_layout SourceCode
   SOURCE FILE: <class source file> 
\end_layout

\begin_layout SourceCode
   OUTPUT FILE: <differentiated class destination file> 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
CLASS <DifferentiatedClass> (<ClassBeingDifferentiated>) 
\end_layout

\begin_layout SourceCode
   SOURCE FILES: <class source file> <class header file> 
\end_layout

\begin_layout SourceCode
   OUTPUT FILES: <differentiated class destination file> 
\begin_inset Newline newline
\end_inset

                 <differentiated class header file> 
\end_layout

\begin_layout Standard
The CLASS entry names the class (DifferentiatedClass) resulting from the
 application of the AD operations and the class (ClassBeingDifferentiated)
 whose methods are being AD'd.
 The implementation of the class being differentiated must reside in the
 SOURCE FILE and the resulting differentiated code will reside in the OUTPUT
 FILE.
 In a C++ context you may specify a source file and source file header using
 the SOURCE FILES form.
 Similarly, you may specify an output source file and header file using
 the OUPUT FILES form.
 The source files named must be accessible through one of the paths specified
 in PATHS.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:BOUNDS-CHECK"

\end_inset

BOUNDS CHECK
\end_layout

\begin_layout SourceCode
BOUNDS CHECK fn1, fn2,…,fnN;
\end_layout

\begin_layout Standard
The BOUNDS CHECK entry names the functions whose enclosed code array indexing
 will be bound checked for over / under-runs.
 Functions named in this list need not be pre-existing but should exist
 as a result of any subsequent AD operations.
 Naming non-existent functions will not flag as an error.
 
\end_layout

\begin_layout Standard
Any bounds checked functions in the parent class are re-implemented in the
 differentiated class with bounds checking code included.
 For parent class over-rides the methods must be declared as virtual to
 ensure that the bounds checked version is called.
\end_layout

\begin_layout Subsubsection
FUNCTION
\end_layout

\begin_layout SourceCode
FUNCTION=<function_to_differentiate>
\end_layout

\begin_layout SourceCode
    OUTVAR=<ovar_1[,ovar_2,...,ovar_n]>
\end_layout

\begin_layout SourceCode
    VAR=<diff_wrt_var_1[,diff_wrt_var_2,...,diff_wrt_var_n]>
\end_layout

\begin_layout SourceCode
    MODE=<Tapenade differentiation mode>
\end_layout

\begin_layout SourceCode
    USER=<'extra tapenade command line args'>
\end_layout

\begin_layout SourceCode
    [PRAGMAS=<'Pragma options text'>];
\end_layout

\begin_layout Standard
The FUNCTION entry names the class function / method to be differentiated
 (function_to_differentiate).
 
\end_layout

\begin_layout Standard
The output variable/variables are named by the OUTVAR parameter.
 In the case of an output variable being returned by the function / method,
 it is given the same name as the function.
 The variable/variables to differentiate with respect to is/are named by
 the VAR parameter.
 Names are comma seperated and case insensitive.
\end_layout

\begin_layout Standard
The MODE parameter specifies the mode of automatic differentiation which
 can be one of ,
\end_layout

\begin_layout Description
f forward or tangent mode
\end_layout

\begin_layout Description
r reverse or adjoint mode
\end_layout

\begin_layout Description
m multi-directional tangent mode
\end_layout

\begin_layout Standard
The USER parameter specifies any addition arguments to pass to the command
 line call to TAPENADE.
 This is a string that pasted verbatim into the TAPENADE command line.
 You will typically specify the black box definitions supplied with ADT
 in this argument with the line,
\end_layout

\begin_layout SourceCode
USER='-ext ../include/my_extlib.txt'
\end_layout

\begin_layout Standard
The PRAGMAS option provides a means of specifying switches to alter the
 behaviour of ADT in performing the AD operations.Currently the following
 pragmas are defined.
\end_layout

\begin_layout Description
PushPopDisable Disables the pushing and popping of arrays onto the stack
 / tape in reverse mode differentiation
\end_layout

\begin_layout Description
WithoutStackSubstitution Disables the replacement of PUSH and POP calls
 with arrays.
 This is principally for debugging ADT behaviour.
\end_layout

\begin_layout Description
WithStackSubstitution Enables the replacement of PUSH and POP calls with
 arrays.
 This is principally for debugging ADT behaviour.
\end_layout

\begin_layout Subsection
Make Grammar
\end_layout

\begin_layout Subsubsection*
Keywords
\end_layout

\begin_layout SourceCode
AD BEGIN BOUNDS CHECK CLASS DIRECTORY PASCAL END FILE FILES FORTRAN 
\end_layout

\begin_layout SourceCode
FUNCTION INCLUDE MODE OPTIONS OUTPUT OUTVAR PATHS PRAGMAS 
\end_layout

\begin_layout SourceCode
SOURCE SWITCHES USER VAR WORKING BLACKBOX
\end_layout

\begin_layout Subsubsection*
Tokens
\end_layout

\begin_layout GrammarRule
\noindent
FileName:
\begin_inset Newline newline
\end_inset

A valid file path either quoted or non-quoted.
 Either single or double quote characters may be used.
\end_layout

\begin_layout GrammarRule
Ident:
\begin_inset Newline newline
\end_inset

An identifier starting with a non-numeric character and containing only
 numbers, letters and underscore characters.
\end_layout

\begin_layout GrammarRule
Text:
\begin_inset Newline newline
\end_inset

A string of characters on a single line enclosed in single quotes.
\end_layout

\begin_layout Subsection*
Rules
\end_layout

\begin_layout GrammarRule
MakeCommandList:
\begin_inset Newline newline
\end_inset

MakeCommand
\begin_inset Newline newline
\end_inset

MakeCommandList MakeCommand
\end_layout

\begin_layout GrammarRule
MakeCommand:
\begin_inset Newline newline
\end_inset

AD BEGIN MakeOptionsList ClassList END
\end_layout

\begin_layout GrammarRule
MakeOptionsList:
\begin_inset Newline newline
\end_inset

MakeOption
\begin_inset Newline newline
\end_inset

MakeOptionsList MakeOption
\end_layout

\begin_layout GrammarRule
MakeOption:
\begin_inset Newline newline
\end_inset

PATHS ':' FileNameList ';'
\begin_inset Newline newline
\end_inset

SOURCE FILES ':' FileNameList ';'
\begin_inset Newline newline
\end_inset

WORKING DIRECTORY ':' FileName ';'
\begin_inset Newline newline
\end_inset

CPP OPTIONS FILE ':' FileName ';'
\begin_inset Newline newline
\end_inset

PASCAL OPTIONS FILE ':' FileName ';'
\begin_inset Newline newline
\end_inset

FORTRAN INCLUDE FILES ':' FileNameList ';'
\begin_inset Newline newline
\end_inset

SWITCHES ':' FileNameList ';'
\begin_inset Newline newline
\end_inset

BLACKBOX ':' FileNameList ';'
\end_layout

\begin_layout GrammarRule
FileNameList:
\begin_inset Newline newline
\end_inset

FileName
\begin_inset Newline newline
\end_inset

FileNameList ',' FileName
\end_layout

\begin_layout GrammarRule
ClassList:
\begin_inset Newline newline
\end_inset

ClassBlock
\begin_inset Newline newline
\end_inset

ClassList ClassBlock
\end_layout

\begin_layout GrammarRule
ClassBlock:
\begin_inset Newline newline
\end_inset

ClassBlockBegin AutoDiffCommandList END
\begin_inset Newline newline
\end_inset

ClassBlockBegin END
\end_layout

\begin_layout GrammarRule
ClassBlockBegin:
\begin_inset Newline newline
\end_inset

CLASS Ident '(' Ident ')' SOURCE FILE ':' FileName OUTPUT FILE ':' FileName
 BEGIN
\begin_inset Newline newline
\end_inset

CLASS Ident '(' Ident ')' SOURCE FILE ':' FileName OUTPUT FILES ':' FileName
 FileName BEGIN
\begin_inset Newline newline
\end_inset

CLASS Ident '(' Ident ')' SOURCE FILES ':' FileName FileName OUTPUT FILE
 ':' FileName BEGIN
\begin_inset Newline newline
\end_inset

CLASS Ident '(' Ident ')' SOURCE FILES ':' FileName FileName OUTPUT FILES
 ':' FileName FileName BEGIN
\end_layout

\begin_layout GrammarRule
AutoDiffCommandList:
\begin_inset Newline newline
\end_inset

AutoDiffCommand
\begin_inset Newline newline
\end_inset

AutoDiffCommandList AutoDiffCommand
\begin_inset Newline newline
\end_inset

AutoDiffCommand:AutoDiffCommandOpList ';'
\end_layout

\begin_layout GrammarRule
AutoDiffCommandOpList:
\begin_inset Newline newline
\end_inset

AutoDiffCommandOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandOpList AutoDiffCommandOp
\end_layout

\begin_layout GrammarRule
AutoDiffCommandOp:
\begin_inset Newline newline
\end_inset

AutoDiffCommandFunctionOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandVarOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandOutVarOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandModeOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandUserOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandPragmasOp
\begin_inset Newline newline
\end_inset

AutoDiffCommandBoundsCheckOp
\end_layout

\begin_layout GrammarRule
AutoDiffCommandFunctionOp:
\begin_inset Newline newline
\end_inset

FUNCTION '=' Ident
\end_layout

\begin_layout GrammarRule
AutoDiffCommandVarOp:
\begin_inset Newline newline
\end_inset

VAR '=' NameList
\end_layout

\begin_layout GrammarRule
AutoDiffCommandOutVarOp:
\begin_inset Newline newline
\end_inset

OUTVAR '=' NameList
\end_layout

\begin_layout GrammarRule
AutoDiffCommandModeOp:
\begin_inset Newline newline
\end_inset

MODE '=' Ident
\end_layout

\begin_layout GrammarRule
AutoDiffCommandUserOp:
\begin_inset Newline newline
\end_inset

USER '=' Text
\end_layout

\begin_layout GrammarRule
AutoDiffCommandPragmasOp:
\begin_inset Newline newline
\end_inset

PRAGMAS '=' Text
\end_layout

\begin_layout GrammarRule
AutoDiffCommandBoundsCheckOp:
\begin_inset Newline newline
\end_inset

M_BOUNDS M_CHECK NameList ';'
\end_layout

\begin_layout GrammarRule
NameList:
\begin_inset Newline newline
\end_inset

Ident
\begin_inset Newline newline
\end_inset

NameList ',' Ident
\end_layout

\begin_layout Section
\begin_inset CommandInset label
LatexCommand label
name "sec:ADT-Automatic-R"

\end_inset

ADT Automatic R Interface Code
\end_layout

\begin_layout Standard
Writing scientific code that interfaces with R is a complex an error prone
 task.
 To simplify this process ADT provides a means to automatically create most
 of the interface code for you.
 This feature is controlled by the inclusion of comments in the source code
 that form automation commands which ADT then interprets to produce the
 desired code.
\end_layout

\begin_layout Subsection
Array Dimension Comments
\end_layout

\begin_layout Standard
ADT needs to know the sizes of arrays in a project class to both correctly
 carry out AD operations and to produce correct interface code.
 We tell ADT the array sizes through inline comments appearing immediately
 after the declaration of the array in question.
 The required comment syntax is
\begin_inset Foot
status open

\begin_layout Plain Layout
The square brackets enclose optional parameters
\end_layout

\end_inset

,
\end_layout

\begin_layout SourceCode
/*[lower bound index 1:]upper bound index 1, 
\end_layout

\begin_layout SourceCode
  [lower bound index 2:]upper bound index 2, ..., 
\end_layout

\begin_layout SourceCode
  [lower bound index n:]upper bound index n*/
\end_layout

\begin_layout Standard
for C++ code and,
\end_layout

\begin_layout SourceCode
{[lower bound index 1:]upper bound index 1, 
\end_layout

\begin_layout SourceCode
 [lower bound index 2:]upper bound index 2, ..., 
\end_layout

\begin_layout SourceCode
 [lower bound index n:]upper bound index n}
\end_layout

\begin_layout Standard
for Pascal code.
 The lower bound index is optional and if omitted is assumed to be 1.
 For example,
\end_layout

\begin_layout SourceCode
ARRAY_2D   my_array_a/*m,n*/;
\end_layout

\begin_layout SourceCode
ARRAY_2D   my_array_b/*4:p,-1:q+1*/; 
\end_layout

\begin_layout Standard
in C++ and,
\end_layout

\begin_layout SourceCode
my_array_a{m,n}        : ARRAY_2D; 
\end_layout

\begin_layout SourceCode
my_array_b{4:p,-1:q+1} : ARRAY_2D; 
\end_layout

\begin_layout Standard
in Pascal, both declare two arrays of doubles: 
\emph on
my_array_a
\emph default
 whose first index is between 1 and 
\emph on
m
\emph default
 and whose second index is between 1 and 
\emph on
n
\emph default
, and 
\emph on
my_array_b
\emph default
 whose first index is between 4 and 
\emph on
p
\emph default
 and whose second index is between -1 and 
\emph on
q
\emph default
+1.
 Any variable index limit must be defined as an attribute of the class.
 
\end_layout

\begin_layout Standard
Ragged array definitions are also possible through specifying the ragged
 dimensions with a vector of indices.
 For instance,
\end_layout

\begin_layout SourceCode
ARRAY_2L   n_obs_y_r /*n_year,n_region*/;
\end_layout

\begin_layout SourceCode
ARRAY_3D   obs /*n_region,n_year,n_obs_y_r[<2>,<1>]*/;
\end_layout

\begin_layout SourceCode
ARRAY_3D   alt_obs /*n_year,n_region,n_obs_y_r[<-2>,<-1>]*/;
\end_layout

\begin_layout Standard
in C++ and,
\end_layout

\begin_layout SourceCode
n_obs_y_r {n_year,n_region}                    : ARRAY_2L;
\end_layout

\begin_layout SourceCode
obs {n_region,n_year,n_obs_y_r[<2>,<1>]}       : ARRAY_3D;
\end_layout

\begin_layout SourceCode
alt_obs {n_year,n_region,n_obs_y_r[<-2>,<-1>]} : ARRAY_3D;
\end_layout

\begin_layout Standard
in Pascal, define two ragged arrays 
\shape italic
obs
\shape default
 and 
\shape italic
alt_obs
\shape default
 whose third dimension is ragged and specified by the array 
\shape italic
n_obs_y_r
\shape default
.
 Any ragged array indice will be distinguishable from a non-ragged one by
 the presence of an indexing specification that determines which indices
 of the size array are driven by which indicies of the ragged array.
 In the example above for the array 
\shape italic
obs
\shape default
 the third index size (
\family typewriter
n_obs_y_r[<2>,<1>]
\family default
) is obtained from 
\shape italic
n_obs_y_r
\shape default
 using 
\shape italic
n_year
\shape default
 (implied by 
\family typewriter
<2>
\family default
 which instructs adt to use the second index of 
\shape italic
obs
\shape default
 to index into 
\shape italic
n_obs_y_r
\shape default
) as the first index and 
\shape italic
n_region
\shape default
 as the second one (implied by 
\family typewriter
<1>
\family default
 which instructs adt to use the first index of 
\shape italic
obs
\shape default
 to index into 
\shape italic
n_obs_y_r
\shape default
).
 For the case of 
\shape italic
alt_obs
\shape default
 negative / relative indexing is used.
 For negative indexing the datum is relative to the index from where the
 specification occurs so the 
\family typewriter
<-2>
\family default
 means the index two places to the left of this one or the 
\shape italic
n_year
\shape default
 index.
 In positive indexing the datum is absolute and is the first index of the
 array being specified, thus the 
\family typewriter
<1>
\family default
 refers to the 
\shape italic
n_region
\shape default
 index.
\end_layout

\begin_layout Standard
Array dimension comments are also used to declared the dimension of arguments
 in functions and subroutines but in this context ragged array dimensioning
 is not supported.
 For example,
\end_layout

\begin_layout SourceCode
double my_func(int ix, 
\end_layout

\begin_layout SourceCode
               int n, 
\end_layout

\begin_layout SourceCode
               const ARRAY_1D array_a /*n*/, 
\end_layout

\begin_layout SourceCode
               ARRAY_1D array_b /*m*/);
\end_layout

\begin_layout Standard
in C++ or,
\end_layout

\begin_layout SourceCode
FUNCTION my_func(ix, n: LONGINT; 
\end_layout

\begin_layout SourceCode
                 CONST array_a {n}, array_b {m}: ARRAY_1D): DOUBLE;
\end_layout

\begin_layout Standard
in Pascal.
\end_layout

\begin_layout Subsection
Preprocessor Comment Commands
\end_layout

\begin_layout Standard
By providing preprocessor commands in code comments ADT can automatically
 generate R interface code to interface your library with R.
 Every class which is to have automatically generated code must have an
 AD_ALIAS command appearing as the first command in the class definition.
 
\end_layout

\begin_layout Standard
Class attributes are either automatically intialised, or null initialised
 or not declared or initialised depending on whether they are define in
 the scope of AUTOINIT, AUTODEC and MANUAL commands.
 Furthermore, the timing of the initialisation operations can be controlled
 with a phase parameter applied in these commands.
\end_layout

\begin_layout Subsubsection
AD_LIBNAME command
\end_layout

\begin_layout Standard
If a library is to interface with R and have all interface routines registered
 with R when the library is loaded you must tell ADT the name of the library.
 This is done using the AD_LIBNAME command whose general form is,
\end_layout

\begin_layout SourceCode
AD_LIBNAME Library_Name
\end_layout

\begin_layout Standard
This command can appear anywhere in the class definition.
 
\end_layout

\begin_layout Subsubsection
AD_ALIAS command
\end_layout

\begin_layout Standard
Every class that is to have an interface to R and have automatically generated
 constructor code must provide and AD_ALIAS command.
 In fact if no AD_ALIAS command is found no further preprocessing is performed.
 The AD_ALIAS command must be the first command the preprocessor reads.
 The general form of the command is,
\end_layout

\begin_layout SourceCode
AD_ALIAS Alias_Name=D_Class_Name[, Parent_Class_Name]
\end_layout

\begin_layout Standard
where the 
\emph on
Parent_Class_Name
\emph default
 parameter is optional and only used when a class derives from a class that
 has an AD_ALIAS command in its definition.
 In such cases it is necessary to name the parent class so that the automaticall
y generated constructor will call the parent class constructor correctly.
 The simple C++ example,
\end_layout

\begin_layout SourceCode
class MySpecialClass : public AdtArrays 
\end_layout

\begin_layout SourceCode
{ 
\end_layout

\begin_layout SourceCode
  /* AD_ALIAS MC=D_MySpecialClass */
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
defines 
\emph on
MC
\emph default
 as the 
\emph on
Alias Name
\emph default
 of the class 
\emph on
D_MySpecialClass
\emph default
.
 As it doesn't derive from a preprocessed class we do not use the 
\emph on
Parent_Class_Name
\emph default
 parameter.
 In Pascal code this would look like,
\end_layout

\begin_layout SourceCode
MySpecialClass = class(Tuseful_obj)
\end_layout

\begin_layout SourceCode
  {AD_ALIAS MC=D_MySpecialClass} 
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
end;
\end_layout

\begin_layout Standard
Note that 
\shape italic
D_Class_Name
\shape default
 refers to the class name for the derived output class from any AD operations
 and applies equally to null differentiation steps.
 The reason the derived class is used is so that ADT can then automatically
 generate interface code to methods produced as a result of AD operations.
 The 
\shape italic
D_Class_Name
\shape default
 entry must match that of the derived class as specified in the make file,
 which in the above case would be something like,
\end_layout

\begin_layout SourceCode
CLASS D_MySpecialClass (MySpecialClass) ...
 
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:AUTOINIT-command"

\end_inset

AUTOINIT command
\end_layout

\begin_layout Standard
Class attributes can be automatically initialised through the constructor
 by placing an AUTOINIT command before their declaration in the class definition.
 The command applies to all attribute declarations in the class appearing
 after the command.
 If no command is provided it defaults to MANUAL, meaning the code author
 is responsible for initialising the code.
 All attributes that are auto-initialised have corresponding initialisation
 arguments in the constructor for the class.
 
\end_layout

\begin_layout Standard
The general form of the command is,
\end_layout

\begin_layout SourceCode
AUTOINIT [phase_number]
\end_layout

\begin_layout Standard
where 
\emph on
phase_number
\emph default
 is an optional parameter that sets the phase of initialisation for the
 attributes in question.
 If not specified the 
\emph on
phase_number
\emph default
 defaults to 1.
 For example,
\end_layout

\begin_layout SourceCode
class MySpecialClass : public AdtArrays 
\end_layout

\begin_layout SourceCode
{ 
\end_layout

\begin_layout SourceCode
  /* AD_ALIAS MC=MySpecialClass */
\end_layout

\begin_layout SourceCode
  /* AUTOINIT */
\end_layout

\begin_layout SourceCode
  int N
\end_layout

\begin_layout SourceCode
  ARRAY_1D M/*N*/
\end_layout

\begin_layout SourceCode
  /* AUTOINIT 2 */
\end_layout

\begin_layout SourceCode
  double P
\end_layout

\begin_layout SourceCode
  double Q
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  MySpecialClass(
\end_layout

\begin_layout SourceCode
  #include 
\begin_inset Quotes eld
\end_inset

MC_constructor_args.hpp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout SourceCode
  );
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
or in Pascal,
\end_layout

\begin_layout SourceCode
MySpecialClass = class(AdtArrays) 
\end_layout

\begin_layout SourceCode
  { AD_ALIAS MC=MySpecialClass }
\end_layout

\begin_layout SourceCode
  { AUTOINIT }
\end_layout

\begin_layout SourceCode
  N      : longint;
\end_layout

\begin_layout SourceCode
  M {N}  : ARRAY_1D;
\end_layout

\begin_layout SourceCode
  { AUTOINIT 2 }
\end_layout

\begin_layout SourceCode
  P  : double;
\end_layout

\begin_layout SourceCode
  Q  : double;
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  MySpecialClass({$I MC_constructor_args.pas});
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
end;
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:AUTODEC-command"

\end_inset

AUTODEC command
\end_layout

\begin_layout Standard
Class attributes can be automatically null initialised through the constructor
 by placing an AUTODEC command before their declaration in the class definition.
 The command applies to all attribute declarations in the class appearing
 after the command.
 If no command is provided it defaults to MANUAL, meaning the code author
 is responsible for initialising the code.
 
\end_layout

\begin_layout Standard
The general form of the command is,
\end_layout

\begin_layout SourceCode
AUTODEC [phase_number] [NO_INTERFACE]
\end_layout

\begin_layout Standard
where 
\emph on
phase_number
\emph default
 is an optional parameter that sets the phase of initialisation for the
 attributes in question and 
\shape italic
NO_INTERFACE
\shape default
 is an optional parameter that instructs ADT to not generate an R interface
 for the attributes to follow.
 If not specified the 
\emph on
phase_number
\emph default
 defaults to 1 and interfaces are created.
 The latter option is needed so that array types such as 
\shape italic
ARRAY_?B
\shape default
 or 
\shape italic
ARRAY_?UI
\shape default
 may be used within a class without resulting in errors as these and other
 types do not have equivalents in an R environment and therefore cannot
 be mapped.
 For example,
\end_layout

\begin_layout SourceCode
class MySpecialClass : public AdtArrays 
\end_layout

\begin_layout SourceCode
{ 
\end_layout

\begin_layout SourceCode
  /* AD_ALIAS MC=MySpecialClass */
\end_layout

\begin_layout SourceCode
  /* AUTOINIT */
\end_layout

\begin_layout SourceCode
  int N
\end_layout

\begin_layout SourceCode
  ARRAY_1D M/*N*/
\end_layout

\begin_layout SourceCode
  /* AUTOINIT 2 */
\end_layout

\begin_layout SourceCode
  double P
\end_layout

\begin_layout SourceCode
  double Q
\end_layout

\begin_layout SourceCode
  /* AUTODEC */
\end_layout

\begin_layout SourceCode
  int R
\end_layout

\begin_layout SourceCode
  /* AUTODEC 2 */
\end_layout

\begin_layout SourceCode
  ARRAY_2D S
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  MySpecialClass(
\end_layout

\begin_layout SourceCode
  #include 
\begin_inset Quotes eld
\end_inset

MC_constructor_args.hpp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout SourceCode
  );
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
will put null-initialisation code for 
\emph on
R
\emph default
 into the include file 
\emph on
MC_constructor_scalars_1.hpp
\emph default
 and null-initialisation code for 
\emph on
S
\emph default
 into 
\emph on
MC_constructor_arrays_2.hpp
\emph default
.
 For Pascal context the include file names are the same but with a 
\emph on
.pas
\emph default
 file extension.
 The equivalent in Pascal is,
\end_layout

\begin_layout SourceCode
MySpecialClass = class(AdtArrays) 
\end_layout

\begin_layout SourceCode
  { AD_ALIAS MC=MySpecialClass }
\end_layout

\begin_layout SourceCode
  { AUTOINIT }
\end_layout

\begin_layout SourceCode
  N      : longint;
\end_layout

\begin_layout SourceCode
  M {N}  : ARRAY_1D;
\end_layout

\begin_layout SourceCode
  { AUTOINIT 2 }
\end_layout

\begin_layout SourceCode
  P  : double;
\end_layout

\begin_layout SourceCode
  Q  : double;
\end_layout

\begin_layout SourceCode
  { AUTODEC }
\end_layout

\begin_layout SourceCode
  R  : longint;
\end_layout

\begin_layout SourceCode
  { AUTODEC 2 }
\end_layout

\begin_layout SourceCode
  S  : ARRAY_2D;
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  MySpecialClass({$I MC_constructor_args.pas});
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
end;
\end_layout

\begin_layout Subsubsection
MANUAL command
\end_layout

\begin_layout Standard
Class attributes that are declared after a MANUAL command must be manually
 initialised in the author code.
 The general form of this command is,
\end_layout

\begin_layout SourceCode
MANUAL
\end_layout

\begin_layout Standard
If no AUTOINIT, AUTODEC or MANUAL commands appear any defined attributes
 are treated as MANUAL defined attributes.
 Furthermore, manual attributes will not be accessible from R as they have
 no automatically generated interface code.
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:BLACKBOX-and-D/D"

\end_inset

BLACKBOX and D/D commands
\end_layout

\begin_layout Standard
Sometimes TAPENADE may need to create differentiated code for functions
 that can be easily differentiated by hand.
 For such functions if we provide a black box definition that specifies
 the derivative then TAPENADE can make more efficient code by not generating
 differentiated versions of the function but rather using the black box
 definition to produce the differentiated code.
 We can provide black box definitions to those sorts of functions through
 a special comment block that appears immediately before the function declaratio
n or implementation, but not both.
 For example,
\end_layout

\begin_layout SourceCode
// < D/D(x) (4 * x) - 5; >
\end_layout

\begin_layout SourceCode
double polyX(double x);
\end_layout

\begin_layout Standard
declares that the C++ function 
\family typewriter
polyX()
\family default
 has the differential with respect to 
\begin_inset Formula $x$
\end_inset

 of 
\begin_inset Formula $4x-5$
\end_inset

.
 Similarly in Pascal we would have,
\end_layout

\begin_layout SourceCode
{ < D/D(x) (4 * x) - 5; > }
\end_layout

\begin_layout SourceCode
function polyX(x : double) : double;
\end_layout

\begin_layout Standard
The 
\begin_inset Quotes eld
\end_inset

less than
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

greater than
\begin_inset Quotes erd
\end_inset

 braces are required in inline definitions and are used to isolate the black
 box definition from other general code comments.
 Quite often differentials of functions with more than one variable will
 have a common term to the partial differentials and then specific terms
 for each dependent variable.
 This is supported in the black box specification language as is illustrated
 by the following contrived example.
\end_layout

\begin_layout SourceCode
// < D/D(.) -(x^2 + 4*y)^-2,
\end_layout

\begin_layout SourceCode
//   D/D(x) .*2*x,
\end_layout

\begin_layout SourceCode
//   D/D(y) .*4; >
\end_layout

\begin_layout SourceCode
double polyXY(double x, double y);
\end_layout

\begin_layout Standard
Note that ^ is used as a 
\begin_inset Quotes eld
\end_inset

raised to the power of
\begin_inset Quotes erd
\end_inset

 operator which can also be specified by the Fortran styled equivalent **.
 This example defines the common term as 
\begin_inset Formula $-\left(x^{2}+4y\right)^{-2}$
\end_inset

 and the extra multiplicative terms with respect to 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 respectively of 
\begin_inset Formula $2x$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

, giving the complete partial differentials for 
\family typewriter
polyXY()
\family default
 as, 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\partial polyXY}{\partial x}=-2x\left(x^{2}+4y\right)^{-2}
\]

\end_inset


\end_layout

\begin_layout Standard
and,
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\frac{\partial polyXY}{\partial y}=-4\left(x^{2}+4y\right)^{-2}
\]

\end_inset


\end_layout

\begin_layout Standard
The expressions defining the derivation can include function calls provided
 the named functions have themselves blackbox definitions or are part of
 the standard blackbox definitions provided by TAPENADE (Fortran instrinsics
 such as COS, SIN, LOG, EXP and so on).
 For example,
\end_layout

\begin_layout SourceCode
// < D/D(x) -sin(x) + 2 * cos(2*x); >
\end_layout

\begin_layout SourceCode
double trigExpression(double x);
\end_layout

\begin_layout Standard
The black box definitions can be defined using either single line or multiple
 line comments in Pascal and C++ languages.
 If you wish to include a 
\begin_inset Quotes eld
\end_inset

black box
\begin_inset Quotes erd
\end_inset

 comment you can make use of the # symbol to designate a single line black
 box comment.
 There is no multiline comment support for black box definitions.
 For example, we might comment the above with,
\end_layout

\begin_layout SourceCode
// < D/D(x) -sin(x) + 2 * cos(2*x); # derivative of trigExpression >
\end_layout

\begin_layout SourceCode
double trigExpression(double x);
\end_layout

\begin_layout Standard
In addition to specifying the nature of the differential we can also tell
 TAPENADE more detail about the function parameters and whether they are
 inputs or outputs, both or neither.
 This is done with a BLACKBOX statement along the lines of, 
\end_layout

\begin_layout SourceCode
// < BLACKBOX ReadNotWritten:(1,1,0)
\end_layout

\begin_layout SourceCode
//            NotReadThenWritten:(0,0,1)
\end_layout

\begin_layout SourceCode
//            deps:(1,1,0,1,1,0,id);
\end_layout

\begin_layout SourceCode
//   D/D(.) -(x^2 + 4*y)^-2,
\end_layout

\begin_layout SourceCode
//   D/D(x) .*2*x,
\end_layout

\begin_layout SourceCode
//   D/D(y) .*4; >
\end_layout

\begin_layout SourceCode
double polyXY(double x, double y);
\end_layout

\begin_layout Standard
The keywords 
\family typewriter
ReadNotWritten
\family default
, 
\family typewriter
NotReadThenWritten
\family default
, 
\family typewriter
ReadThenWritten
\family default
, 
\family typewriter
NotReadNotWritten
\family default
 and 
\family typewriter
deps
\family default
 have the same meaning as is documented in the TAPENADE FAQ covering black
 box routines so for a detailed explaination please refer to it (see 
\family typewriter
https://www-sop.inria.fr/tropics/tapenade/faq.html#Libs1
\family default
 assuming it hasn't changed addresses).
 For general use the BLACKBOX statement is not necessary and ADT will provide
 reasonable defaults for those parameters through inspection of the function
 prototype.
 Note that any function provided with an inline blackbox definition will
 not be included in the normal AD processing of ADT as if it were excluded
 using conditional compilation statements (
\family typewriter
ifndef AD
\family default
).
\end_layout

\begin_layout Standard
If using an external library to provide some numerical calculations for
 which access to the source code is not provided, black box definitions
 will be necessary to allow TAPENADE to produce differentials for any code
 that makes use of it.
 In this case, as there is no source code, inline blackbox definitions cannot
 be provided, but ADT provides a alternative means of providing them.
 To do so we create a standalone black box definition file which is referenced
 in the BLACKBOX part (see 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:BLACKBOX"

\end_inset

) of the ADT make file.
 The syntax is the same as for inline definitions but sandwhiched within
 a Pascal styled function or procedure definition with comment delimiters
 removed.
 The 
\begin_inset Quotes eld
\end_inset

less than
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

greater than
\begin_inset Quotes erd
\end_inset

 bracing is not required in standalone definitions.
 For example,
\end_layout

\begin_layout SourceCode
# Black box definition for polyX
\end_layout

\begin_layout SourceCode
function polyX(x : real in) : real
\end_layout

\begin_layout SourceCode
begin
\end_layout

\begin_layout SourceCode
  D/D(x) (4 * x) - 5;
\end_layout

\begin_layout SourceCode
end
\end_layout

\begin_layout Standard
Alternatively, if 
\family typewriter
polyX
\family default
 were implemented as a procedure we define it as,
\end_layout

\begin_layout SourceCode
# Black box definition for polyX
\end_layout

\begin_layout SourceCode
procedure polyX(x : real in, result : real)
\end_layout

\begin_layout SourceCode
begin
\end_layout

\begin_layout SourceCode
  D/D(x) (4 * x) - 5;
\end_layout

\begin_layout SourceCode
end
\end_layout

\begin_layout Standard
You can have as many definitions as needed within a file, or you can group
 them into different files and name each file in the BLACKBOX part of the
 ADT makefile.
 
\end_layout

\begin_layout Standard
For a complete definition of the black box language refer to 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:Black-Box-Grammar"

\end_inset

.
\end_layout

\begin_layout Subsection
Automatically Generated Files
\end_layout

\begin_layout Subsubsection
\begin_inset CommandInset label
LatexCommand label
name "sub:{Alias_Name}_constructor_args-fi"

\end_inset

{Alias_Name}_constructor_args file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_constructor_args
\emph default
 file contains the constructor argument list and includes all the variables
 necessary to initialise all the class attributes declared in AUTOINIT scope.
 The file should be included in the declaration and implementation of the
 constructor.
 For example,
\end_layout

\begin_layout SourceCode
class MySpecialClassB : public MySpecialClass 
\end_layout

\begin_layout SourceCode
{ 
\end_layout

\begin_layout SourceCode
  /* AD_ALIAS MCB=D_MySpecialClassB, MySpecialClass */
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  #include "MCB_array_plans.hpp"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  MySpecialClassB(
\end_layout

\begin_layout SourceCode
  #include 
\begin_inset Quotes eld
\end_inset

MCB_constructor_args.hpp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout SourceCode
  );
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
for the declaration and,
\end_layout

\begin_layout SourceCode
MySpecialClassB::MySpecialClassB(
\end_layout

\begin_layout SourceCode
  #include 
\begin_inset Quotes eld
\end_inset

MCB_constructor_args.hpp
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout SourceCode
  )
\end_layout

\begin_layout SourceCode
 : MySpecialClass(
\end_layout

\begin_layout SourceCode
     #include "MCB_constructor_call_args.hpp"
\end_layout

\begin_layout SourceCode
   )
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  #include "MCB_constructor_locals.hpp"
\end_layout

\begin_layout SourceCode
  #include "MCB_constructor_scalars_phase_1.hpp"
\end_layout

\begin_layout SourceCode
  #include "MCB_constructor_arrays_phase_1.hpp"
\end_layout

\begin_layout SourceCode
  #include "MCB_array_plans_init.hpp"
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
for the implementation in C++.
 For Pascal the example would be,
\end_layout

\begin_layout SourceCode
MySpecialClassB = class(MySpecialClass)
\end_layout

\begin_layout SourceCode
  {AD_ALIAS MCB=MySpecialClassB, MySpecialClass}
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  {$I MCB_array_plans.pas}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  constructor create({$I MCB_constructor_args.pas});
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
and,
\end_layout

\begin_layout SourceCode
constructor MySpecialClassB.create({$I MCB_constructor_args.pas});
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
var
\end_layout

\begin_layout SourceCode
  {$I MCB_constructor_locals.pas}
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
begin
\end_layout

\begin_layout SourceCode
  inherited create({$I MCB_constructor_call_args.pas});
\end_layout

\begin_layout SourceCode
  {$I MCB_constructor_scalars_phase_1.pas}
\end_layout

\begin_layout SourceCode
  {$I MCB_constructor_arrays_phase_1.pas}
\end_layout

\begin_layout SourceCode
  {$I MCB_array_plans_init.pas}
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
end;
\end_layout

\begin_layout Subsubsection
{Alias_Name}_constructor_call_args file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_constructor_call_args
\emph default
 file contains the argument list required to call the parent constructor.
 This file should be included in the implementation of the constructor.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:{Alias_Name}_constructor_args-fi"

\end_inset

 for an example of its usage.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_constructor_locals file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_constructor_locals
\emph default
 file contains declarations of local variables needed to carry out the automatic
 initialisation of class attributes in the constructor.
 This file should be included in the constructor implementation.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:{Alias_Name}_constructor_args-fi"

\end_inset

 for an example of its usage.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_constructor_scalars_phase file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_constructor_scalars_phase
\emph default
 file contains code to intialise scalars.
 There are as many phase files as there are phases defined through AUTOINIT
 and AUTODEC commands.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AUTOINIT-command"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AUTODEC-command"

\end_inset

 for more details on initialisation phases.
 
\end_layout

\begin_layout Standard
The author of the code is responsible for including the 
\emph on
{Alias_Name}_constructor_scalars_phase
\emph default
 files in the correct order and location and is free to add any custom initialis
ation code in between include commands.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:{Alias_Name}_constructor_args-fi"

\end_inset

 for an example of usage.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_constructor_arrays_phase file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_constructor_arrays_phase
\emph default
 file contains code to intialise arrays.
 There are as many phase files as there are phases defined through AUTOINIT
 and AUTODEC commands.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AUTOINIT-command"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:AUTODEC-command"

\end_inset

 for more details on initialisation phases.
 
\end_layout

\begin_layout Standard
The author of the code is responsible for including the 
\emph on
{Alias_Name}_constructor_arrays_phase
\emph default
 files in the correct order and location and is free to add any custom initialis
ation code in between include commands.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:{Alias_Name}_constructor_args-fi"

\end_inset

 for an example of usage.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_impl_lib_interface_methods file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_impl_lib_interface_methods
\emph default
 file contains automatically generated code to interface your class with
 R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_impl_lib_interface_globals file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_impl_lib_interface_globals
\emph default
 file contains automatically generated code to interface your class with
 R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_decl_lib_interface_methods file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_decl_lib_interface_methods
\emph default
 file contains the automatically generated interface method declarations
 that interface your class with R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_decl_lib_interface_globals file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_decl_lib_interface_globals
\emph default
 file contains the automatically generated interface function declarations
 that interface your class with R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_decl_lib_interface_constructor file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_decl_lib_interface_constructor
\emph default
 file contains the automatically generated constructor and destructor function
 declarations that interface your class with R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_impl_lib_interface_constructor file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_impl_lib_interface_constructor
\emph default
 file contains automatically generated constructor and destructor function
 implementations that interface your class with R.
 This file is automatically included in the derived class implementation
 generated by ADT.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_impl_lib_registration file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_impl_lib_registration
\emph default
 file contains automatically generated R interface registration code which
 must be part of the R library being compiled.
 This file should be included in the project file for a Pascal library,
 for example:
\end_layout

\begin_layout SourceCode
library RosenbrockPas;
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
uses
\end_layout

\begin_layout SourceCode
  Classes, MinRosenbrock_Unit,
\end_layout

\begin_layout SourceCode
  D_MinRosenbrock_Unit, R_MinRosenbrock_Unit,
\end_layout

\begin_layout SourceCode
  DR_MinRosenbrock_Unit, adtarray, Raccess;
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
// ----------------------------------------------------------------------------
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
{$I RRb_impl_lib_registration.pas}
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
exports
\end_layout

\begin_layout SourceCode
  {$I RRb_lib_exports.pas};
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
begin
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
end.
\end_layout

\begin_layout Standard
In the case of a C++ project a source file should be added to the project
 that includes this file along with the header files for the derived classes
 being interfaced to.
 In the Rosenbrock project case the added file is 
\shape italic
registration.cpp
\shape default
 and contains the following:
\end_layout

\begin_layout SourceCode
// ----------------------------------------------------------------------------
\end_layout

\begin_layout SourceCode
// Code to register R interface for the Test minimisation example code for
 ADT.
\end_layout

\begin_layout SourceCode
// ----------------------------------------------------------------------------
\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode

\end_layout

\begin_layout SourceCode
#include "DR_Rosenbrock.hpp"
\end_layout

\begin_layout SourceCode
#include "RRb_impl_lib_registration.hpp"
\end_layout

\begin_layout Subsubsection
{Alias_Name}_lib_exports file (Pascal only)
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_lib_exports
\emph default
 file contains a comma seperated list of all the functions to export as
 the dynamic library interface.
 This file is required for Pascal projects and should be included in the
 
\emph on
exports
\emph default
 statement of your project file.
 For example,
\end_layout

\begin_layout SourceCode
exports
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  {$I MCB_lib_exports.pas};
\end_layout

\begin_layout Standard
C++ projects do not use this file and export symbols through the function
 declaration itself.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_array_plans file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_array_plans
\emph default
 file contains the declaration of necessary 
\emph on
AdtArrayPlan
\emph default
 objects needed to initialise arrays in 
\emph on
{Alias_Name}_constructor_arrays_phase 
\emph default
files.
 This file should be included along side the other attributes of your class.
 See section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sub:{Alias_Name}_constructor_args-fi"

\end_inset

 for a examples of usage.
\end_layout

\begin_layout Subsubsection
{Alias_Name}_R_interface.r file
\end_layout

\begin_layout Standard
The 
\emph on
{Alias_Name}_R_interface.r
\emph default
 file contains 
\emph on
R
\emph default
 code implementing get and set method accessors and code to instantiate
 and interact with your class.
 
\end_layout

\begin_layout Standard
The R 
\shape italic
create
\shape default
 function is used to create an instance of the class and comforms to the
 following naming convention.
\end_layout

\begin_layout SourceCode
{Alias_Name}.create <- function({initialisation argument list})
\end_layout

\begin_layout Standard
The initialisation argumenst contain one argument per AUTOINIT class attribute
 in the constructor call.
 For example, the Rosenbrock demonstration project has the 
\shape italic
create
\shape default
 function,
\end_layout

\begin_layout SourceCode
RRb.create <- function(N)
\end_layout

\begin_layout Standard
The 
\shape italic
create
\shape default
 function returns a pointer to the object instance to R which must be saved
 for use as the instance pointer in calling the object instance methods.
 For example,
\end_layout

\begin_layout SourceCode
RRb.Context <- RRb.create(150)
\end_layout

\begin_layout Standard
Before calling the 
\shape italic
create
\shape default
 function it is necessary to load the dynamic library using a call to 
\emph on
dyn.load()
\emph default
.
 For example,
\end_layout

\begin_layout SourceCode
dyn.load("../../objs/sample/Rosenbrock/.libs/librosenbrock.so")
\end_layout

\begin_layout Standard
For each attribute that is AUTOINITialised, ADT creates 
\emph on
get
\emph default
 and 
\emph on
set
\emph default
 R wrapper functions to easily access your attribute data.
 Furthermore, these accessors assume the identical array structure as in
 the class, including the indexing base.
 This is acheived through the use of the 
\emph on
Oarray
\emph default
 package to provide abstracted array indexing.
 The motivation behind this one to one correspondence is to aid in debugging
 the library code.
 The 
\emph on
get
\emph default
 and 
\emph on
set
\emph default
 methods are named through the templates,
\end_layout

\begin_layout SourceCode
{Alias_Name}.get.{Attribute_Name} <- function(Context, ...)
\end_layout

\begin_layout Standard
and,
\end_layout

\begin_layout SourceCode
{Alias_Name}.set.{Attribute_Name} <- function(Context, Arg, ...)
\end_layout

\begin_layout Standard
Notice that both the set and get functions can index a subset of the attribute
 being called.
 For example, if we hade a 3 dimensional array called 
\shape italic
PopAgeAreaTime
\shape default
 then we could inspected the entire array content with,
\end_layout

\begin_layout SourceCode
PopMod.get.PopAgeAreaTime(Context)
\end_layout

\begin_layout Standard
the two dimensional array subset at Age 2 with,
\end_layout

\begin_layout SourceCode
PopMod.get.PopAgeAreaTime(Context, 2)
\end_layout

\begin_layout Standard
the one diemsional array subset at Age 2 and Area 3 with,
\end_layout

\begin_layout SourceCode
PopMod.get.PopAgeAreaTime(Context, 2, 3)
\end_layout

\begin_layout Standard
and the single value at Age 2, Area 3 and Time 1 with,
\end_layout

\begin_layout SourceCode
PopMod.get.PopAgeAreaTime(Context, 2, 3, 1)
\end_layout

\begin_layout Standard
The same equally applies to the setter methods though in that case the second
 argument in the call must correspond to the value/values you are setting
 it to and needs to be of size and shape suitable to initialise the attribute
 in question.
 For example,
\end_layout

\begin_layout SourceCode
PopMod.set.PopAgeAreaTime(Context, ScalarValue, 2, 3, 1)
\end_layout

\begin_layout Standard
For each public method in the class ADT creates an R wrapper call with the
 name based on the template,
\end_layout

\begin_layout SourceCode
{Alias_Name}.{Method_Name} <- function(Context, {function argument list})
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout SourceCode
{Alias_Name}.nt.{Method_Name} <- function(Context, {function argument list})
\end_layout

\begin_layout Standard
The R wrapper function has one plus the same number of arguments as the
 method it wraps, the first argument always being the object instance pointer.
 There are two variants of the interface methods that are created for each
 class method, both with the same call arguments.
 The reason for this has to do with format translation.
 To ellaborate, arrays in R are represented internally in column major format
 whereas C++ and Pascal languages represent arrays in row major format.
 To aid in debugging code it is nice to have a common representational framework
 whether in a R context or a C++ / Pascal context so ADT normally translates
 the array representation when passing parameters from R code to C++ / Pascal
 code and visa versa via a transpose operation.
 This is true for all constructor arguments and the 
\shape italic
get
\shape default
 and 
\shape italic
set
\shape default
 methods.
 However, if a function must be called repeatedly (for example, when passing
 your class function to the 
\shape italic
nlminb()
\shape default
 minimizer function in R) it can be wasteful of computing resources to be
 continually transposing matrices to make such method calls.
 Therefore we have two implementations : one with transposition and one
 without.
 The one without is given the 
\shape italic
.nt.

\shape default
 modified name, 
\shape italic
.nt.

\shape default
 meaning 
\shape italic
no transpose
\shape default
.
 
\end_layout

\begin_layout Subsection
\begin_inset CommandInset label
LatexCommand label
name "sub:Black-Box-Grammar"

\end_inset

Black Box Grammar
\end_layout

\begin_layout Standard
The lexer ignores C++ and Pascal comment delimiters.
 Inline blackbox definitions must be braced by 
\begin_inset Quotes eld
\end_inset

less than
\begin_inset Quotes erd
\end_inset

 (<) and 
\begin_inset Quotes eld
\end_inset

greater than
\begin_inset Quotes erd
\end_inset

 (>) symbols.
 Line comments can be included in black box definitions by begining the
 line with the 
\family typewriter
#
\family default
 character.
 Note that in an inline definition the comment start must appear after the
 language comment delimiter.
 For example,
\end_layout

\begin_layout SourceCode
// # This is a valid black box comment in C++ code
\end_layout

\begin_layout SourceCode
# // This is NOT a valid black box comment in C++ code
\end_layout

\begin_layout SourceCode
{ # This is a valid black box comment in Pascal code }
\end_layout

\begin_layout SourceCode
# { This is NOT a valid black box comment in Pascal code }
\end_layout

\begin_layout GrammarRule
Keywords
\begin_inset Newline newline
\end_inset

begin BLACKBOX boolean boolean_array character character_array complex complex_a
rray D/D end function id in integer integer_array NotReadNotWritten NotReadThenW
ritten out procedure ReadNotWritten ReadThenWritten real real_array result
\end_layout

\begin_layout Subsubsection*
Tokens
\end_layout

\begin_layout GrammarRule
Identifier:
\begin_inset Newline newline
\end_inset

An identifier starting with a non-numeric character and containing only
 numbers, letters and underscore characters.
\end_layout

\begin_layout GrammarRule
DecimalLiteral:
\begin_inset Newline newline
\end_inset

An integer number.
\end_layout

\begin_layout GrammarRule
FloatingPointLiteral:
\begin_inset Newline newline
\end_inset

A floating point number.
\end_layout

\begin_layout Subsection*
Rules
\end_layout

\begin_layout GrammarRule
root:
\begin_inset Newline newline
\end_inset

derivativeList
\end_layout

\begin_layout GrammarRule
derivativeList:
\begin_inset Newline newline
\end_inset

derivative
\begin_inset Newline newline
\end_inset

derivativeList derivative
\end_layout

\begin_layout GrammarRule
MakeOptionsList:
\begin_inset Newline newline
\end_inset

MakeOption
\begin_inset Newline newline
\end_inset

MakeOptionsList MakeOption
\end_layout

\begin_layout GrammarRule
derivative:
\begin_inset Newline newline
\end_inset

'D/D' '(.)' exprAdditive ',' derivativeExtendedList ';'
\begin_inset Newline newline
\end_inset

'D/D' '(' Identifier ')' exprAdditive ';'
\begin_inset Newline newline
\end_inset

'BLACKBOX' blackBoxSpecList ';'
\begin_inset Newline newline
\end_inset

'procedure' Identifier '(' argDefList ') 'begin' derivativeList 'end'
\begin_inset Newline newline
\end_inset

'function' Identifier '(' argDefList ')' ':' argType 'begin' derivativeList
 'end'
\end_layout

\begin_layout GrammarRule
derivativeExtended:
\begin_inset Newline newline
\end_inset

'D/D' '(' Identifier ')' '.' '*' exprAdditive
\end_layout

\begin_layout GrammarRule
derivativeExtendedList:
\begin_inset Newline newline
\end_inset

derivativeExtended
\begin_inset Newline newline
\end_inset

derivativeExtendedList ',' derivativeExtended
\end_layout

\begin_layout GrammarRule
argType:
\begin_inset Newline newline
\end_inset

'real'
\begin_inset Newline newline
\end_inset

'integer'
\begin_inset Newline newline
\end_inset

'complex'
\begin_inset Newline newline
\end_inset

'character'
\begin_inset Newline newline
\end_inset

'boolean'
\begin_inset Newline newline
\end_inset

'real_array'
\begin_inset Newline newline
\end_inset

'integer_array'
\begin_inset Newline newline
\end_inset

'complex_array'
\begin_inset Newline newline
\end_inset

'character_array'
\begin_inset Newline newline
\end_inset

'boolean_array'
\end_layout

\begin_layout GrammarRule
dirType:
\begin_inset Newline newline
\end_inset

'in'
\begin_inset Newline newline
\end_inset

'out'
\begin_inset Newline newline
\end_inset

'in' 'out'
\begin_inset Newline newline
\end_inset

'out' 'in'
\end_layout

\begin_layout GrammarRule
argDef:
\begin_inset Newline newline
\end_inset

Identifier ':' argType dirType
\begin_inset Newline newline
\end_inset

Identifier ':' dirType argType
\begin_inset Newline newline
\end_inset

'result' ':' argType
\end_layout

\begin_layout GrammarRule
argDefList:
\begin_inset Newline newline
\end_inset

argDef
\begin_inset Newline newline
\end_inset

argDefList ',' argDef
\end_layout

\begin_layout GrammarRule
blackBoxSpecList:
\begin_inset Newline newline
\end_inset

blackBoxSpec
\begin_inset Newline newline
\end_inset

blackBoxSpecList blackBoxSpec
\end_layout

\begin_layout GrammarRule
blackBoxSpec:
\begin_inset Newline newline
\end_inset

'ReadNotWritten' ':' '(' identList ')'
\begin_inset Newline newline
\end_inset

'NotReadThenWritten' ':' '(' identList ')'
\begin_inset Newline newline
\end_inset

'NotReadNotWritten' ':' '(' identList ')'
\begin_inset Newline newline
\end_inset

'ReadThenWritten' ':' '(' identList ')'
\begin_inset Newline newline
\end_inset

'deps' ':' '(' identList ')'
\end_layout

\begin_layout GrammarRule
ident:
\begin_inset Newline newline
\end_inset

'id'
\begin_inset Newline newline
\end_inset

DecimalLiteral
\end_layout

\begin_layout GrammarRule
identList:
\begin_inset Newline newline
\end_inset

ident
\begin_inset Newline newline
\end_inset

identList ',' ident
\end_layout

\begin_layout GrammarRule
exprAdditive:
\begin_inset Newline newline
\end_inset

exprMultiplicative
\begin_inset Newline newline
\end_inset

exprAdditive '+' exprMultiplicative
\begin_inset Newline newline
\end_inset

exprAdditive '-' exprMultiplicative
\end_layout

\begin_layout GrammarRule
exprMultiplicative:
\begin_inset Newline newline
\end_inset

exprPower
\begin_inset Newline newline
\end_inset

exprMultiplicative '*' exprPower
\begin_inset Newline newline
\end_inset

exprMultiplicative '/' exprPower
\end_layout

\begin_layout GrammarRule
exprPower:
\begin_inset Newline newline
\end_inset

exprUnary
\begin_inset Newline newline
\end_inset

exprPower '^' exprUnary
\begin_inset Newline newline
\end_inset

exprPower '**' exprUnary
\end_layout

\begin_layout GrammarRule
exprUnary:
\begin_inset Newline newline
\end_inset

exprPostfix
\begin_inset Newline newline
\end_inset

'+' exprPostfix
\begin_inset Newline newline
\end_inset

'-' exprPostfix
\end_layout

\begin_layout GrammarRule
exprPostfix:
\begin_inset Newline newline
\end_inset

DecimalLiteral
\begin_inset Newline newline
\end_inset

FloatingPointLiteral
\begin_inset Newline newline
\end_inset

Identifier
\begin_inset Newline newline
\end_inset

Identifier '(' argList ')'
\begin_inset Newline newline
\end_inset

Identifier '(' exprAdditive ')'
\end_layout

\begin_layout GrammarRule
argList:
\begin_inset Newline newline
\end_inset

exprAdditive
\begin_inset Newline newline
\end_inset

argList ',' exprAdditive
\end_layout

\begin_layout Chapter
ADT Internals
\end_layout

\begin_layout Standard
Here we outline the internal structure and operation of ADT for the specific
 purpose of aiding in the maintenance of the software.
 The source code behind the software is large and is daunting to contemplate
 without first hand knowledge, but the software has a coherent structure
 should aid in any future development.
 In order to maximise portablility and minimise dependencies, ADT does not
 make use of anything other than ANSI C++ and STL.
 Anything we need we construct from this foundation and deliberately avoid
 using large monolithic libraries such as boost.
 This keeps ADT a compact package with minimal build requirements.
 Any future development should adhere to this practice.
\end_layout

\begin_layout Section
Common Code
\end_layout

\begin_layout Standard
A significant portion of the code in ADT is common code that is used throughout
 in many contexts.
 Here we detail the majority of that common code.
 
\end_layout

\begin_layout Subsection
String Class
\end_layout

\begin_layout Standard
The string class used extensively in ADT is typedefed as 
\emph on
string
\emph default
 ind is a template instantiation of the template class 
\emph on
string_ext
\emph default
 which derives from the STL string class 
\emph on
std::basic_string
\emph default
.
 The derived and extended version adds string concatenation operations using
 overloaded + operators, a c string pointer cast operator, some common string
 manipulation methods, caseless string comparison, and most importantly,
 overrides the constructors and assignment operators to fix a dangerous
 behaviour in the STL version.
 The class is declared and implemented in 
\emph on
adtcommon.hpp
\emph default
 
\end_layout

\begin_layout Standard
In particular, the STL 
\emph on
basic_string
\emph default
 class has an optimisation whereby if you assign to a string object another
 string object it will share pointers to the internal string representation
 to conserve memory.
 Whilst it sounds like a nice idea, in practice it causes no end of trouble
 because you may happen to be assigning from a temporary string object (say
 an object on the stack or an aggregate of a class that will soon be destroyed)
 which then becomes invalid when the parent dies.
 If it were implemented properly with a reference counted pointer to the
 internal buffer then such a strategy would be fine, but the naive implementatio
n within does not do so, thus making it more trouble than it is worth.
 Therefore, all the ways of assigning a string object to a string object
 (constructors and assignment operators) are overridden and call the private
 method 
\emph on
forceCopy()
\emph default
 to ensure that pointers are never shared.
\end_layout

\begin_layout Subsection
ReferenceCount Class
\end_layout

\begin_layout Standard
In ADT many objects are shared objects to be shared between many clients.
 Those classes that are to be shared need to be reference counted to manage
 the life cycle.
 This is handled by deriving all shared classes from the 
\emph on
UtlReferenceCount
\emph default
 class defined in 
\emph on
adtcommon.hpp
\emph default
.
 It has three methods : 
\emph on
lock()
\emph default
 to increment the reference count, 
\emph on
unlock()
\emph default
 to decrement the reference count and 
\emph on
lockCount()
\emph default
 to query the lock count.
 When calling the 
\emph on
unlock()
\emph default
 method you should check the return value and if 
\emph on
true
\emph default
 the 
\emph on
delete
\emph default
 operator should be called on the object instance to free the object.
 This is handled cleanly by using the helper macro 
\emph on
UtlReleaseReference()
\emph default
 to release an object no longer needed.
 
\end_layout

\begin_layout Standard
This behaviour could have been built into the 
\emph on
unlock()
\emph default
 method but doing so then makes automatic instances of the class impossible
 (ie.
 creating a class instance without using 
\emph on
new()
\emph default
).
 It is left as the client responsibility to free the class so that stack/automat
ic instances of the class can be used.
 
\end_layout

\begin_layout Subsection
UtlFilePath Class
\end_layout

\begin_layout Standard
File names are commonly manipulated in ADT so to simplify this processing
 and to share the code needed for the manipulation of file names we have
 created the 
\emph on
UtlFilePath
\emph default
 class.
 This class takes a filename with or without full path extension and splits
 it up into 
\emph on
Drive
\emph default
, 
\emph on
Directory
\emph default
, 
\emph on
Name
\emph default
 and 
\emph on
Extension
\emph default
 components, which can subsequently be modified and joined to form a new
 file name and path.
 This class correctly handles the differences of file name representations
 in Linux / Unix and Windows / DOS.
 Provided you use this class to manipulate file names then you need not
 worry about the file name represenational differences between different
 operating systems.
 This class is declared in 
\emph on
adtcommon.hpp
\emph default
 and implemented in 
\emph on
adtcommon.cpp
\emph default
.
 
\end_layout

\begin_layout Subsection
AdtParse Namespace
\end_layout

\begin_layout Standard
Though most of the parsing required in ADT is handled through Flex and Bison
 generated lexers and parsers, some internal stuff needs to be handled manually
 (parsing automation commands and array size specifications within comment
 blocks for example).
 To that end we have a series of functions that aid in writing parsers declared
 in the 
\emph on
AdtParse
\emph default
 namespace in the file 
\emph on
adtutils.hpp
\emph default
.
 The code is largely self explanatory and usage can be easily determine
 by grep'ing for usage within ADT so I'll refrain from going into any detail
 about this, suffice to say, that if you need to do a hand written parser
 then consider using the functions already available in 
\emph on
AdtParse
\emph default
 rather than introducing extra code.
\end_layout

\begin_layout Subsection
AdtFile Class
\end_layout

\begin_layout Standard
Within ADT we spend a lot of time creating formatted source files in different
 languages.
 To aid in creating nicely formated output files we make use of the 
\emph on
AdtFile
\emph default
 class.
 This class has methods to write strings and chars, insert new lines and
 tabs and change indentation (the level of tabbing to be applied after a
 new line character).
 The output can be directed either to a file or a string object.
 If 
\emph on
AdtFile
\emph default
 is opened as a Fortran file, it also correctly handles the creation of
 Fortran continuation lines.
 
\end_layout

\begin_layout Standard
If you need to write formated output to a text file you should make use
 of 
\emph on
AdtFile
\emph default
 as it will make the code preparation considerably easier.
 This class is declared in 
\emph on
adtutils.hpp
\emph default
 and again, usage is pretty self explanatory with many examples easily found
 by grep'ing for usage within ADT.
\end_layout

\begin_layout Subsection
AdtFileCopy Class
\end_layout

\begin_layout Standard
In various places we are required to create copies of text files.
 As an aid to this we have created a file copying class called 
\emph on
AdtFileCopy
\emph default
 which is declared in 
\emph on
adtutils.hpp
\emph default
.
 Search for it in 
\emph on
adtmake.cpp
\emph default
 for an example of it's usage.
 
\end_layout

\begin_layout Subsection
AdtStringCache Class
\end_layout

\begin_layout Standard
When parsing the Pascal, C++ and Fortran source files, ADT creates complete
 object based parse trees for the code.
 In the token stream there is a lot of text that needs to be allocated in
 strings but much of that text is repeated text representing the same token
 so to store each individually wastes a lot of memory and hinders the performanc
e of ADT.
 To avoid this problem all string tokens in the lexer stream are allocated
 through a global instance of the 
\emph on
AdtStringCache
\emph default
 class, which returns a pointer to a single allocation of the one name through
 the 
\emph on
add()
\emph default
 method.
 Thus, if we add the string 
\emph on
MyVar
\emph default
 three times in a row it will only allocate one copy in memory and return
 the same representation to the caller in the other two cases.
 This class is declared in 
\emph on
adtutils.hpp
\emph default
 and is used by all the flex generated lexers in ADT.
 
\end_layout

\begin_layout Section
Make System
\end_layout

\begin_layout Standard
The make system is the over-arching component of ADT responsible for orchestrati
ng the correct sequence of operations needed to build a particular ADT make
 file.
 The makefile parsing is carried out by a flex / bison generated parser.
 The tokeniser is implemented in 
\emph on
make_l.l
\emph default
 and the parser in 
\emph on
make_y.y
\emph default
 .
 The make system code resides in 
\emph on
adtmake.hpp
\emph default
 and 
\emph on
adtmake.cpp
\emph default
.
 
\end_layout

\begin_layout Subsection
Processing Flow Chart
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

% Define block styles
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{decision} = [diamond, aspect=2, draw, fill=blue!20, text width=8em,
 text badly centered, node distance=3cm, inner sep=0pt]
\end_layout

\begin_layout Plain Layout


\backslash
tikzstyle{block} = [rectangle, draw, fill=blue!20, text width=15em, text
 centered, rounded corners, minimum height=2em] 
\backslash
tikzstyle{line} = [draw, -latex'] 
\backslash
tikzstyle{cloud} = [draw, ellipse,fill=red!20, node distance=3cm, minimum
 height=2em]
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{tikzpicture}[node distance = 2cm, auto]
\end_layout

\begin_layout Plain Layout

% Place nodes
\end_layout

\begin_layout Plain Layout


\backslash
node [block] (compile_sources) {Compile all source files};
\end_layout

\begin_layout Plain Layout


\backslash
node [block, below of=compile_sources] (process_class_source) {Preprocess
 and compile class source file, expand macros and flatten the class into
 a single class with no parent};
\end_layout

\begin_layout Plain Layout


\backslash
node [block, below of=process_class_source] (run_tapenade) {Write fortran
 code and run Tapenade AD operation};
\end_layout

\begin_layout Plain Layout


\backslash
node [block, below of=run_tapenade] (merge_results) {Compile fortran result
 and merge new source into working result replacing push/pops with arrays};
\end_layout

\begin_layout Plain Layout


\backslash
node [left of=merge_results, node distance=5cm, inner sep=0pt, minimum height=0p
t] (next_AD) {};
\end_layout

\begin_layout Plain Layout


\backslash
node [right of=merge_results, node distance=5cm, inner sep=0pt, minimum
 height=0pt] (next_class) {};
\end_layout

\begin_layout Plain Layout


\backslash
node [decision, below of=merge_results] (more_AD) {More AD operations?};
\end_layout

\begin_layout Plain Layout


\backslash
node [block, below of=more_AD, node distance=3cm] (slice_fixups) {Expand
 slice operations, expand macros and write resulting AD'd class source files};
\end_layout

\begin_layout Plain Layout


\backslash
node [decision, below of=slice_fixups] (more_classes) {More classes to process?}
;
\end_layout

\begin_layout Plain Layout


\backslash
node [block, below of=more_classes, node distance=3cm] (stop) {Finished};
\end_layout

\begin_layout Plain Layout

% Draw edges
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (compile_sources) -- (process_class_source);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (process_class_source) -- (run_tapenade);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (run_tapenade) -- (merge_results);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (merge_results) -- (more_AD);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (more_AD.west) -| node [near start] {yes} (next_AD) |- (run_tapenade)
;
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (more_AD) -- node {no}(slice_fixups);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (slice_fixups) -- (more_classes);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (more_classes.east) -| node [near start] {yes} (next_class) |-
 (process_class_source);
\end_layout

\begin_layout Plain Layout


\backslash
path [line] (more_classes) -- node {no}(stop);
\end_layout

\begin_layout Plain Layout


\backslash
end{tikzpicture} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The simplified make processing is as shown in the flow chart.
 It begins with all the source files named in the SOURCE FILES section of
 the make file being compiled.
 
\end_layout

\begin_layout Standard
Then, for all classes we start by pre-processing and compiling the named
 source file and expanding macros.
 The pre-processing referred to here is those comment embedded commands
 used to define and implement an R interface to the class (see Section 
\begin_inset CommandInset ref
LatexCommand ref
reference "sec:ADT-Automatic-R"

\end_inset

).
 The macro expansions are those defined in CPP OPTIONS FILE or PASCAL OPTIONS
 FILE (depending on whether the source code is C++ or Pascal).
\end_layout

\begin_layout Standard
The parse tree of the flattened class source is then written as equivalent
 Fortran 95 code and TAPENADE is invoked, carrying out the desired AD operation
 on the Fortran code.
 
\end_layout

\begin_layout Standard
The resulting AD'ed Fortran code is then compiled and any new Functions
 or Subroutines that TAPENADE created are integrated into the working Fortran
 parse tree.
 Within that process of integration, all instances of 
\emph on
PUSH
\emph default
, 
\emph on
POP
\emph default
, 
\emph on
PUSHARRAY
\emph default
 and 
\emph on
POPARRAY
\emph default
 must be substituted with stack arrays.
 This step is a requirement to allow TAPENADE to apply further AD operations
 on top of reverse mode AD'ed code.
 
\end_layout

\begin_layout Standard
We continue with this processing until all AD operations defined for the
 given CLASS have been carried out.
 When all have been carried out we finalise the processing for that class
 by first expanding slice operations into an equivalent set of calls to
 
\emph on
XCOPY
\emph default
 and / or 
\emph on
ZERO
\emph default
, then translating the working Fortran source into an equivalent C++ or
 Pascal source (depending on the source code language).
 We do this for all CLASS definitions in the makefile.
 
\end_layout

\begin_layout Standard
The bulk of the processing handled by the make system is implemented in
 the 
\emph on
AdtMakeSystem::make()
\emph default
, 
\emph on
AdtMakeCommand::make()
\emph default
 and 
\emph on
AdtMakeClass::make()
\emph default
 methods.
\end_layout

\begin_layout Subsection
Incremental Compile
\end_layout

\begin_layout Standard
The implicit assumption on which the ADT incremental compile system is based
 is that every successive step in an ADT make file is dependent upon the
 previous one.
 That being the case, when an AD operation is changed in the middle of a
 list of AD operations (contained in a CLASS entry within the makefile)
 then that AD operation and every other operation following is re-evaluated.
 when ADT is re-run.
 
\end_layout

\begin_layout Standard
This mechanism is managed by the 
\emph on
AdtMakeIncremental
\emph default
 class defined in 
\emph on
adtmake.hpp
\emph default
 and implemented in 
\emph on
adtmake.cpp
\emph default
.
 The principle of operation is through simple string comparison.
 An instance of 
\emph on
AdtMakeIncremental
\emph default
 is created and then opens the dependency check file through the 
\emph on
open()
\emph default
 method.
 If the file exists (which is the case when an ADT make file has previously
 been processed) then it reads the entire contents of the file into the
 
\emph on
ReferenceString
\emph default
 attribute of the class.
 Then, scattered throughout the make processing are calls to the 
\emph on
checkText()
\emph default
, 
\emph on
checkList()
\emph default
, 
\emph on
checkMap()
\emph default
 and 
\emph on
checkFile()
\emph default
 methods.
 Each of these methods serialises the objects being checked in a string
 format and stores it in the 
\emph on
CheckString
\emph default
 attribute.
 This string is then checked against 
\emph on
ReferenceString
\emph default
.
 If it matches then we know nothing has changed so no re-building is required
 but if it doesn't then we flag it as needing to be rebuilt.
 When the entire make has been run 
\emph on
CheckString
\emph default
 is then written to the dependency check file, updating the dependency informati
on ready for any subsequent build.
 
\end_layout

\begin_layout Standard
One other thing the make system needs from the increment compile infrastructure
 is knowledge about new methods and attributes resulting from the carried
 out AD operations.
 Normally this information is garnered through carrying out the AD operations
 but if the AD operation is bypassed because it was carried out in a previous
 make then we need to restore this information.
 This is the purpose of the 
\emph on
updateNewMethodsAndAttributes()
\emph default
 method, which both extracts previously stored new method and attribute
 lists from the dependency check file and merges new changes resulting from
 any carried out operations into these lists to create an update set that
 is written to the dependency check file at the completion of the make operation.
 
\end_layout

\begin_layout Section
Code Parsers
\end_layout

\begin_layout Subsection
Common Code Parser Infrastructure
\end_layout

\begin_layout Standard
The code (as in Pascal, C++ and Fortran) parsers share much code in common.
 Many of the operations required to manage the parse results are the same
 so it makes sense to keep as much of this shared functionality in common
 code.
 
\end_layout

\begin_layout Standard
All the parsers in ADT function in the same way, by parsing the source file
 into an object based parse tree with objects corresponding to the non-terminals
 in the grammar file definition for the language, giving a one to one correspond
ence between the grammar and the parse tree output.
 This approach, whilst not a memory efficient way of handling it, provides
 benefits in other ways by making the translation and manipulation of the
 code simple and straight forward.
 
\end_layout

\begin_layout Standard
The evaluated rules are translated into an object tree by creating the objects
 through C wrapper functions that are called in the C statements for the
 rule.
 For example, the non-terminal for 
\emph on
conditional_expression
\emph default
 in the C++ grammar is,
\end_layout

\begin_layout SourceCode
conditional_expression : logical_or_expression
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  $$.pContext = adtCppConditionalExpression_create($1.pContext, 0, 0);
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout SourceCode
  | logical_or_expression QUESTION expression COLON assignment_expression
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  $$.pContext = adtCppConditionalExpression_create($1.pContext, 
\end_layout

\begin_layout SourceCode
                                                   $3.pContext, 
\end_layout

\begin_layout SourceCode
                                                   $5.pContext);
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
The root of the tree at any point in time is in the 
\emph on
$$.pContext
\emph default
 state for the parser.
 The parser state is represented by the corresponding language struct in
 the lexer.h file.
 For C++ it is,
\end_layout

\begin_layout SourceCode
typedef struct cppType
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  void*       pContext;
\end_layout

\begin_layout SourceCode
  const char* sValue;
\end_layout

\begin_layout SourceCode
  double      dValue;
\end_layout

\begin_layout SourceCode
  int         nBlockDepth;
\end_layout

\begin_layout SourceCode
  const char* sComment;
\end_layout

\begin_layout SourceCode
} cppType; 
\end_layout

\begin_layout Standard
The state is of the same structure for the other supported languages.
 As mentioned before, 
\emph on
pContext
\emph default
 holds the root of the parse tree to that point in processing.
 
\emph on
sValue
\emph default
 and 
\emph on
dValue
\emph default
 hold string and numerical results that require persisting in the parser
 state, 
\emph on
nBlockDepth
\emph default
 is used to track the code scoping level (how many nested scopes we are
 in at this point in parsing), and 
\emph on
sComment
\emph default
 holds any comment string associated with the parsing of the current rule.
 
\end_layout

\begin_layout Standard
In the case of the above example, a logical expression object is created
 and assigned to 
\emph on
pContext
\emph default
 through the call the the corresponding non-terminal create function, in
 this case 
\emph on
adtCppConditionalExpression_create()
\emph default
.
 The create function has as many parameters as required to fully describe
 all the rules that lead to the non-terminal in question.
 In the cases where extra parameters aren't required the unused inputs are
 set to appropriate defaults (typically 0).
 
\end_layout

\begin_layout Standard
Note that the $1, $2, ...
 variables return the state corresponding to the corresponding non-terminal
 in the rule.
 In the above example 
\emph on
$1.pContext
\emph default
 returns the 
\emph on
logical_or_expression
\emph default
 object, 
\emph on
$3.pContext
\emph default
 returns the 
\emph on
expression
\emph default
 object and 
\emph on
$5.pContext
\emph default
 returns the 
\emph on
assignment_expression
\emph default
 object.
 
\end_layout

\begin_layout Standard
For list non-terminals the requirements is a little bit different.
 For example, again in the C++ grammar we have,
\end_layout

\begin_layout SourceCode
simple_declaration_list : simple_declaration 
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  $$.pContext = adtCppSimpleDeclarationList_create($1.pContext); 
\end_layout

\begin_layout SourceCode
}  
\end_layout

\begin_layout SourceCode
  | simple_declaration_list simple_declaration
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  $$.pContext = adtCppList_add($1.pContext, $2.pContext);
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
In the case of the first rule we again need to call the corresponding create
 function to create the list, but for list insertions we then call the 
\emph on
adtCppListAdd()
\emph default
 function
\begin_inset Foot
status open

\begin_layout Plain Layout
the same applies to other languages but the function name changes, for example,
 we use 
\emph on
adtDelphiList_add()
\emph default
 for Pascal code
\end_layout

\end_inset

 to insert the object into the list.
 
\end_layout

\begin_layout Standard
The C wrapper functions are again all very similar in construction.
 For example,
\end_layout

\begin_layout SourceCode
void* adtCppConditionalExpression_create(void* pLogicalOrExpressionObj,
\end_layout

\begin_layout SourceCode
                                         void* pExpressionObj, 
\end_layout

\begin_layout SourceCode
                                         void* pAssignmentExpressionObj)
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
 return (Hnd(new AdtCppConditionalExpression(
\end_layout

\begin_layout SourceCode
                       ObjAndRelease(pLogicalOrExpressionObj), 
\end_layout

\begin_layout SourceCode
                       ObjAndRelease(pExpressionObj), 
\end_layout

\begin_layout SourceCode
                       ObjAndRelease(pAssignmentExpressionObj)), 
\end_layout

\begin_layout SourceCode
             yyCpp_lineNumber(), 
\end_layout

\begin_layout SourceCode
             yyCpp_fileName()));
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
Here we coerce the object parameters into the correct type (
\emph on
AdtParser*
\emph default
), pass them as parameters to the constructor of the object that needs creating
 and release the object (decrement a reference count) after the conditional
 expression object has been created.
 This happens through the 
\emph on
ObjAndRelease()
\emph default
 macro call.
 All objects in the parse tree are derived from the 
\emph on
AdtParser
\emph default
 class which implements reference counting for object life cycle management.
 It is for this reason that we need to release the object after the requested
 object is create or else memory leaks will result.
 
\end_layout

\begin_layout Standard
The class 
\emph on
Hnd
\emph default
 is a conversion class to simply convert the 
\emph on
AdtParser*
\emph default
 back into a 
\emph on
void*
\emph default
 needed by the parser and to assign the contextual information (line number
 and filename from 
\emph on
yyCpp_lineNumber()
\emph default
 and 
\emph on
yyCpp_fileName()
\emph default
) to the object instance.
 This contextual information can then be used to give more informative error
 messages in the case of code that does not parse without error.
 
\end_layout

\begin_layout Standard
Comment information, which is usually discarded in normal parsers, in our
 case holds important information that is needed for interpretting how to
 process the code (embedded commands) and as such, is preserved in the parse
 tree.
 The general approach is two fold.
 Firstly, all identifier objects that have inline comments trailing them
 have the comment tokenised in place with the identifier token, which is
 later seperated out into identifier and comment within the class representing
 the identifier.
 Secondly, all other comments are bound to the keyword token that appears
 immediately after the comment.
 If more than one comment construct appears before the keyword token then
 they are concatenated together and bound to the associated keyword object,
 whichever that may be.
 The binding takes the form of a comment string attribute defined in 
\emph on
AdtParser
\emph default
 class accessible via the 
\emph on
AdtParser
\shape italic
\emph default
::comment()
\shape default
 method.
\end_layout

\begin_layout Standard
This basic approach is repeated for all non-terminals in all the supported
 languages.
\end_layout

\begin_layout Standard
Each class representing a non-terminal is derived (indirectly) from 
\emph on
AdtParser
\emph default
.
 In the case of C++ it typically derives directly from 
\emph on
AdtCppBase()
\emph default
 which in turn derives from 
\emph on
AdtParser
\emph default
, with a similar but appropriately named class for the other languages.
 
\emph on
AdtParser
\emph default
 is an abstract base class for which we need to implement a range of methods
 for attribute object management and run time type identification.
 To simplify this repetative coding there are a number of macros used for
 this very purpose.
 We require the 
\emph on
declType
\emph default
 macro to appear in the public section of the class definition and the 
\emph on
implType
\emph default
 macro to appear in the implementation of the class.
 We also need to declare and implement code translation methods to write
 the parse tree in the formats we need to support, in this instance this
 means the 
\emph on
writeCPP
\emph default
 and 
\emph on
writeFortran
\emph default
 methods.
 For example,
\end_layout

\begin_layout SourceCode
class AdtCppConditionalExpression : public AdtCppBase 
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
private:
\end_layout

\begin_layout SourceCode
  AdtCppLogicalOrExpression*    LogicalOrExpression;
\end_layout

\begin_layout SourceCode
  AdtCppExpression*             Expression;
\end_layout

\begin_layout SourceCode
  AdtCppAssignmentExpression*   AssignmentExpression;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
public:
\end_layout

\begin_layout SourceCode
  AdtCppConditionalExpression(AdtParser* pLogicalOrExpressionObj,
\end_layout

\begin_layout SourceCode
                              AdtParser* pExpressionObj,
\end_layout

\begin_layout SourceCode
                              AdtParser* pAssignmentExpressionObj);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  AdtCppConditionalExpression(const AdtCppConditionalExpression& rCopy);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  virtual ~AdtCppConditionalExpression();
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  virtual bool isSimple() const;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  virtual AdtFile& writeCPP(AdtFile& rOutFile,
\end_layout

\begin_layout SourceCode
                            int nMode = 0) const;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  virtual AdtFile& writeFortran(AdtFile& rOutFile,
\end_layout

\begin_layout SourceCode
                                int nMode = 0) const;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  declType;
\end_layout

\begin_layout SourceCode
};
\end_layout

\begin_layout Standard
and,
\end_layout

\begin_layout SourceCode
implType(AdtCppConditionalExpression, AdtCppBase);
\end_layout

\begin_layout Standard
Note that the class definition has corresponding object attributes for each
 non-terminal named in the rule, in this case 
\emph on
LogicalOrExpression
\emph default
, 
\emph on
Expression
\emph default
 and 
\emph on
AssignmentExpression
\emph default
.
 Initialising these object attributes requires a lot of repetitive coding
 which is simplified through macros.
 This we can see in the implementation of the class constructors below.
\end_layout

\begin_layout SourceCode
AdtCppConditionalExpression::AdtCppConditionalExpression(
\end_layout

\begin_layout SourceCode
  AdtParser* pLogicalOrExpressionObj,                                  
                         
\end_layout

\begin_layout SourceCode
  AdtParser* pExpressionObj,                                           
               
\end_layout

\begin_layout SourceCode
  AdtParser* pAssignmentExpressionObj)
\end_layout

\begin_layout SourceCode
  : AdtCppBase()
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  initObject(LogicalOrExpression,
\end_layout

\begin_layout SourceCode
             pLogicalOrExpressionObj,
\end_layout

\begin_layout SourceCode
             AdtCppLogicalOrExpression,
\end_layout

\begin_layout SourceCode
             false);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  initObject(Expression,
\end_layout

\begin_layout SourceCode
             pExpressionObj,
\end_layout

\begin_layout SourceCode
             AdtCppExpression,
\end_layout

\begin_layout SourceCode
             false);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  initObject(AssignmentExpression,
\end_layout

\begin_layout SourceCode
             pAssignmentExpressionObj,
\end_layout

\begin_layout SourceCode
             AdtCppAssignmentExpression,
\end_layout

\begin_layout SourceCode
             false);
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
and
\end_layout

\begin_layout SourceCode
AdtCppConditionalExpression::AdtCppConditionalExpression(
\end_layout

\begin_layout SourceCode
  const AdtCppConditionalExpression& rCopy)
\end_layout

\begin_layout SourceCode
 : AdtCppBase(rCopy)
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  copyObject(LogicalOrExpression,
\end_layout

\begin_layout SourceCode
             rCopy,
\end_layout

\begin_layout SourceCode
             AdtCppLogicalOrExpression);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  copyObject(Expression,
\end_layout

\begin_layout SourceCode
             rCopy,
\end_layout

\begin_layout SourceCode
             AdtCppExpression);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
  copyObject(AssignmentExpression,
\end_layout

\begin_layout SourceCode
             rCopy,
\end_layout

\begin_layout SourceCode
             AdtCppAssignmentExpression);
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
We use the 
\emph on
initObject()
\emph default
 macro to initialise the object instance and the 
\emph on
copyObject()
\emph default
 macro to copy and object instance from another class instance.
 These macros are defined in 
\emph on
adtparser.hpp
\emph default
.
 In the destructor we also need to release the object instances we hold
 on to which we do so with the 
\emph on
UtlReleaseReference()
\emph default
 macro as shown below.
 
\end_layout

\begin_layout SourceCode
AdtCppConditionalExpression::~AdtCppConditionalExpression()
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  UtlReleaseReference(LogicalOrExpression);
\end_layout

\begin_layout SourceCode
  UtlReleaseReference(Expression);
\end_layout

\begin_layout SourceCode
  UtlReleaseReference(AssignmentExpression);
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
This basic coding pattern is repeated throughout for all non-terminals in
 all the supported grammars.
 
\end_layout

\begin_layout Standard
The benefit of this relatively complex approach to building the parser comes
 when we need to interpret it because the base class 
\emph on
AdtParser
\emph default
 provides a great range of services to be able to interpret, search, traverse
 and change the parse tree with little additional coding.
 
\end_layout

\begin_layout Subsubsection
Object Identity
\end_layout

\begin_layout Standard
Run time type identification is of particular importance in being able to
 interpret the parse tree without bloating the code base.
 Rather than relying on the RTTI mechanism available in C++, we implement
 our own string based RTTI which better integrates into the tasks we require
 of it.
 
\end_layout

\begin_layout Standard
Each class that incorporates the 
\emph on
declType()
\emph default
 and 
\emph on
implType()
\emph default
 macros will implement an overidden version of the virtual method 
\emph on
isType()
\emph default
, which takes a single argument being a string naming the class type (which
 is just the name of the class in the code you think it is) and returns
 true if of that type or false otherwise.
 The implementation of 
\emph on
isType()
\emph default
 first calls the parent version of 
\emph on
isType()
\emph default
 so it will correctly identify its type through the inheritance tree.
 
\end_layout

\begin_layout Standard
For example, if we wanted to know if an 
\emph on
AdtParser
\emph default
 pointer object 
\emph on
pParserObj
\emph default
 was an 
\emph on
AdtCppConditionalExpression
\emph default
 object we would do something like,
\end_layout

\begin_layout SourceCode
if (pParserObj->isType(
\begin_inset Quotes eld
\end_inset

AdtCppConditionalExpression
\begin_inset Quotes erd
\end_inset

))
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  // It is an AdtCppConditionalExpression object!
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
  .
\end_layout

\begin_layout SourceCode
}
\end_layout

\begin_layout Standard
Classes that represent list non-terminals should also use the 
\emph on
declListType()
\emph default
 macro to declare the type of object class the list will hold.
 This implements the method 
\emph on
listType()
\emph default
, which returns a string naming the class of the list objects.
 
\end_layout

\begin_layout Subsubsection
Navigating the Parse Tree
\end_layout

\begin_layout Standard
Given the pointer to a AdtParser object of known type, we can navigate to
 a different part of the parse tree with knowledge of the language grammar
 (the objects can only be assembled in a particular manner dictated by the
 grammar).
 
\end_layout

\begin_layout Standard
When a given class is instantiated we use the 
\emph on
initObject()
\emph default
 and 
\emph on
copyObject()
\emph default
 macros to initialise the class attributes.
 Internally, these macros register the attributes by name with the static
 
\emph on
DescendantObjNameList
\emph default
 and 
\emph on
DescendantObjNameMap
\emph default
 attributes of the class.
 
\emph on
DescendantObjNameList
\emph default
 holds the names of all the attributes and 
\emph on
DescendantObjNameMap
\emph default
 holds the relative position of the object in the classes memory layout
 keyed on the attribute name.
 The 
\emph on
DescendantObjNameMap
\emph default
 is used for navigation and replacment of the class attributes with new
 versions.
\end_layout

\begin_layout Standard
Now, if we want to find a particular object in the tree we can make use
 of the method,
\end_layout

\begin_layout SourceCode
  AdtParser* findDescendant(const char* pDescendantPath) const;
\end_layout

\begin_layout Standard
It takes as an argument, a string naming the objects in the search path
 from our root to the desired descendant location.
 The name list is comma separated.
 Multiple search paths can be provided by concatenating them with a semi-colon
 separator.
 The names refer to the names of the objects in the path.
 If you want to decend through a list object then you name the class type
 of the list.
 For example, 
\emph on
this
\emph default
 is an 
\emph on
AdtCppConditionalExpression
\emph default
 object we could descend to the 
\emph on
AdtCppInclusiveOrExpression
\emph default
 in the tree (if indeed there is one) with the code,
\end_layout

\begin_layout SourceCode
AdtParser* pInclusiveOrExpression = 
\end_layout

\begin_layout SourceCode
findDescendant(
\begin_inset Quotes eld
\end_inset

LogicalOrExpression,LogicalAndExpression,InclusiveOrExpression
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
If we want to enumerate all objects in a descendent list non-terminal we
 can use the method,
\end_layout

\begin_layout SourceCode
  void enumerateDescendantList(AdtParserPtrList& rList,
\end_layout

\begin_layout SourceCode
                               const char* pDescendantPath) const;
\end_layout

\begin_layout Standard
which returns all objects in the path in 
\emph on
rList
\emph default
.
 Alternatively, if we want the objects in a map keyed on the object name
 (the string returned by the 
\emph on
name()
\emph default
 method of the object) then we would use,
\end_layout

\begin_layout SourceCode
  void enumerateDescendantMap(AdtParserPtrByStringMap& rMap,
\end_layout

\begin_layout SourceCode
                              const char* pDescendantPath) const;
\end_layout

\begin_layout Standard
and if we know the path contains multiple instances of an object with the
 same name we can obtain all instances keyed on name with a multimap by
 using the method,
\end_layout

\begin_layout SourceCode
void enumerateDescendantMap(AdtParserPtrByStringMultiMap& rMap,
\end_layout

\begin_layout SourceCode
                            const char* pDescendantPath) const;
\end_layout

\begin_layout Standard
As an example, we could enumerate all the declared variables in an 
\emph on
AdtDelphiGoal
\emph default
 object instance with the call,
\end_layout

\begin_layout SourceCode
enumerateDescendantMap(ExportedVariableMap,
\end_layout

\begin_layout SourceCode
                       "Unit,InterfaceSection,VarSection,VarDeclList");
\end_layout

\begin_layout Standard
We can also ascend the tree of objects with,
\end_layout

\begin_layout SourceCode
AdtParser* findAscendantWithClassLineage(const char* pAscendantClassPath,
\end_layout

\begin_layout SourceCode
                                         AdtParser** ppSibling = 0) const;
\end_layout

\begin_layout SourceCode
AdtParser* findAscendantWithClass(const char* pAscendantClass,
\end_layout

\begin_layout SourceCode
                                  AdtParser** ppSibling = 0) const;
\end_layout

\begin_layout Standard
The first version searches through the objects parent list and matches the
 parent class types with the 
\emph on
pAscendantClassPath
\emph default
.
 The second version simple looks for the first instance of the class named
 in 
\emph on
pAscendantClass
\emph default
 in the parent list.
 If the operation fails a null pointer is returned.
\end_layout

\begin_layout Standard
We can find objects that occur in the tree using the methods,
\end_layout

\begin_layout SourceCode
void findObjects(AdtParserPtrList& rList,
\end_layout

\begin_layout SourceCode
                 const char* pClassName,
\end_layout

\begin_layout SourceCode
                 const char* pObjectName = 0,
\end_layout

\begin_layout SourceCode
                 bool bMatchCase = false,
\end_layout

\begin_layout SourceCode
                 const char* pParentClassName = 0,
\end_layout

\begin_layout SourceCode
                 bool bAllowPartialNameMatch = false) const;
\end_layout

\begin_layout SourceCode
AdtParser* findObject(const char* pClassName,
\end_layout

\begin_layout SourceCode
                      const char* pObjectName = 0,
\end_layout

\begin_layout SourceCode
                      bool bMatchCase = false,
\end_layout

\begin_layout SourceCode
                      const char* pParentClassName = 0,
\end_layout

\begin_layout SourceCode
                      bool bAllowPartialNameMatch = false) const;
\end_layout

\begin_layout Standard
The first version finds all instances of the specified objects and returns
 them in 
\emph on
rList
\emph default
, whereas the second version returns a single object instance.
 
\end_layout

\begin_layout Subsubsection
Object Modification
\end_layout

\begin_layout Standard
When we wish to modify the parse tree (say for example, in replacement push
 and pop operations in AD Fortran code with array equivalents) we can do
 so with a host of different methods supporting modification of the class
 attributes.
 These include,
\end_layout

\begin_layout SourceCode
bool add(AdtParser* pObj, bool bAppend = true);
\end_layout

\begin_layout SourceCode
bool insertBefore(const AdtParser* pObj, AdtParser* pInsertObj);
\end_layout

\begin_layout SourceCode
bool insertAfter(const AdtParser* pObj, AdtParser* pInsertObj);
\end_layout

\begin_layout SourceCode
void remove(AdtParser* pObj);
\end_layout

\begin_layout SourceCode
void remove(const char* pObjName);
\end_layout

\begin_layout SourceCode
void removeAllExcept(const AdtParser* pObj);
\end_layout

\begin_layout SourceCode
void removeAllExcept(const char* pObjName);
\end_layout

\begin_layout SourceCode
bool replace(AdtParser* pObj, AdtParser* pListObj);
\end_layout

\begin_layout SourceCode
bool replaceInParent(AdtParser* pObj);
\end_layout

\begin_layout Standard
Many of these methods are self explanatory in there use.
 For further clarification you should search for the usage of these methods
 in the ADT source code to see how you might use them.
 
\end_layout

\begin_layout Standard
This is by no means a comprehensive discussion of the services available
 in 
\emph on
AdtParser
\emph default
 so you should study the class definition to uncover more of what is there,
 but it does serve as a comprehensive introduction of the services available
 so that you don't end up writing unecessary code.
\end_layout

\begin_layout Subsubsection
Parser Abstraction Layers for the Make System
\end_layout

\begin_layout Standard
The make system is required to compile multiple languages (C++, Pascal and
 Fortran) as part of its processing.
 Rather than complicate the code with language based conditionals, the support
 for multipled languages has been abstracted out into two abstract classes,
 
\emph on
AdtCompilerBase
\emph default
 and 
\emph on
AdtSourceRoot
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
AdtCompilerBase
\emph default
 is an abstract base class representing the compiler for a given language.
 All compiler / parsers derive from this to produce a concrete implementation
 for the given language.
 An instance of the 
\emph on
AdtCompiler
\emph default
 class is used to compile source files, which internally determines the
 appropriate compiler class to use in the 
\emph on
createCompilerForFile()
\emph default
 method and assigns the dynamic instance to the 
\emph on
ParserContext
\emph default
 attribute of the class.
 Then the compiler methods,
\end_layout

\begin_layout SourceCode
void parseCommandBlock(const char* pCommandBlock, bool bEmbedded);
\end_layout

\begin_layout SourceCode
bool parse(const char* pFilename,
\end_layout

\begin_layout SourceCode
           const char* pCommandBlock = 0,
\end_layout

\begin_layout SourceCode
           const char* pCommandBlockName = 0,
\end_layout

\begin_layout SourceCode
           const AdtStringList* pSearchPaths = 0,
\end_layout

\begin_layout SourceCode
           bool bForwardMode = true);
\end_layout

\begin_layout SourceCode
bool parseString(AdtParser*& pRoot,
\end_layout

\begin_layout SourceCode
                 const char* pString);
\end_layout

\begin_layout SourceCode
void releaseRoot();
\end_layout

\begin_layout SourceCode
AdtParser* parseRoot() const;
\end_layout

\begin_layout SourceCode
AdtSourceRoot* sourceRoot() const;
\end_layout

\begin_layout Standard
simply delegate to the corresponding methods in 
\emph on
ParserContext
\emph default
.
 
\end_layout

\begin_layout Standard

\emph on
AdtSourceRoot
\emph default
 is an abstract base class from which all root non-terminal classes in the
 language grammar should derive from and implement the abstract methods.
 These methods are the interface in which the make system interacts with
 the parsed source.
 The methods that must be implemented by the root class are,
\end_layout

\begin_layout SourceCode
virtual void enumerateMethodNames(AdtStringList& rMethodList) const = 0;
\end_layout

\begin_layout SourceCode
virtual bool hasClass(const char* pClassName, 
\end_layout

\begin_layout SourceCode
                      string& rParentClassName) const = 0;
\end_layout

\begin_layout SourceCode
virtual bool flattenClass(const char* pClassName, 
\end_layout

\begin_layout SourceCode
                          const AdtParserPtrList& rRootList, 
\end_layout

\begin_layout SourceCode
                          string& rUsesList) = 0;
\end_layout

\begin_layout SourceCode
virtual bool optimise(const AdtStringList& rNewMethodList,
\end_layout

\begin_layout SourceCode
                      const AdtStringByStringMap& rNewMethodMap) = 0;
\end_layout

\begin_layout SourceCode
virtual bool expandMacros() = 0;
\end_layout

\begin_layout SourceCode
virtual bool extractClassConstructors(AdtStringList& rConstructorList,
\end_layout

\begin_layout SourceCode
                                      const char* pClassName,
\end_layout

\begin_layout SourceCode
                                      AdtSourceFileType nAsFileType) const
 = 0;
\end_layout

\begin_layout SourceCode
virtual AdtFile& writeClassMethodsAsFortran(AdtFile& rOutFile,         
                                                                       
       const AdtFortranExecutableProgram* pSavedRoot,
\end_layout

\begin_layout SourceCode
                           const char* pClassName,
\end_layout

\begin_layout SourceCode
                           const char* pLastClassName,
\end_layout

\begin_layout SourceCode
                           bool bExpandMacros) const = 0;
\end_layout

\begin_layout SourceCode
virtual AdtFile& writeNative(AdtFile& rOutFile) const = 0;
\end_layout

\begin_layout SourceCode
virtual AdtSourceFileType sourceFileType() const = 0;
\end_layout

\begin_layout Standard
The intentions of these methods can and should be determined through studying
 the existing code implementations.
 I will not go into any details here.
\end_layout

\begin_layout Standard
The 
\emph on
optimise()
\emph default
 method need not have a non-trivial implementation.
 This entry point is a place whereby loop array referencing optimisations
 can be implemented for Pascal.
 The implementation is currently a null implementation that does nothing,
 meaning ther are no Pascal loop optimisations.
 C++ does not require any such optimisations as the C++ compilers available
 generally already do this, so there is no inherent benefit to implementing
 it.
 For any new language support the remaining methods require proper implementatio
n.
 This applies to the laguages already supported, except in the case of Fortran,
 which only gives non-trivial implementations to 
\emph on
writeNative()
\emph default
 and 
\emph on
sourceFileType()
\emph default
 (and the java support which is a skeleton implementation that isn't complete
 and probably wont be unless a java convert steps in and offers to push
 for it).
 This is the case because Fortran is simply used in managing the working
 files and is not used as a project source language.
 
\end_layout

\begin_layout Subsection
Pascal Parser
\end_layout

\begin_layout Standard
The Pascal parser is implemented through the source files 
\emph on
delphi_l.l
\emph default
, 
\emph on
dephi_y.y
\emph default
, 
\emph on
delphi_inc.h
\emph default
, 
\emph on
delphi_l_wrap.c
\emph default
, 
\emph on
delphi_y_wrap.c
\emph default
, 
\emph on
adtdelphi.hpp
\emph default
 and 
\emph on
adtdelphi.cpp
\emph default
.
 
\end_layout

\begin_layout Standard
The lexer has two states, INITIAL and NOT_AD_CODE.
 The states exist to implement the 
\emph on
$ifdef
\emph default
 
\emph on
$endif
\emph default
 conditional compilation of Pascal code.
 When the code is compiled into the parse tree it is in the INITIAL state
 and when it is being bypassed it is in the NOT_AD_CODE state.
 The conditional compilation handling is implemented using a fixed size
 stack with a maximum depth of 64.
 If there are more than this many levels of nesting of 
\emph on
$ifdef
\emph default
 
\emph on
$endif
\emph default
 blocks then the compilation will fail.
 
\end_layout

\begin_layout Standard
Similarly, the lexer uses a fixed size stack to implement 
\emph on
$include
\emph default
 processing and has a maximum depth of 64.
 If more that 64 nested includes occur then compilation will fail.
\end_layout

\begin_layout Standard
The grammar has one additional non-terminal not part of the language specificati
on, 
\emph on
Macro
\emph default
, which is there to be able to compile the macro expansions that are defined
 in the 
\emph on
pascal_macros.txt
\emph default
 file.
 The rules in that non-terminal with trailing semicolons create a reduce-reduce
 conflict with the other parts of the grammar but this conflict can be safely
 ignored.
 
\end_layout

\begin_layout Standard
Macro expansion is handled in a rather complex manner by direct interpretation
 and manipulation of the parse tree.
 A simpler implementation could be constructed through the use of textual
 code construction parsed by the parser to produce replacement code fragments
 to replace the expression being expanded, as is done for the C++ case.
 This implementation is a legacy of my first attempt and works so will remain
 for the foreseable future.
 If problems arise with it then it should be re-implemented along the suggested
 line.
\end_layout

\begin_layout Standard
The class 
\emph on
AdtDelphi
\emph default
 implements the 
\emph on
AdtCompileBase
\emph default
 specialisation for the support of Pascal code and can be found in the 
\emph on
adtutils.hpp
\emph default
 and 
\emph on
adtutils.cpp
\emph default
 source files.
 
\end_layout

\begin_layout Subsection
C++ Parser
\end_layout

\begin_layout Standard
The C++ parser is implemented through the source files 
\emph on
cpp_l.l
\emph default
, 
\emph on
cpp_y.y
\emph default
, 
\emph on
cpp_inc.h
\emph default
, 
\emph on
cpp_l_wrap.c
\emph default
, 
\emph on
cpp_y_wrap.c
\emph default
, 
\emph on
adtcpp.hpp
\emph default
 and 
\emph on
adtcpp.cpp
\emph default
.
 
\end_layout

\begin_layout Standard
The lexer has two states, INITIAL and NOT_AD_CODE.
 The states exist to implement the 
\emph on
#ifdef
\emph default
 
\emph on
#endif
\emph default
 conditional compilation of C++ code.
 When the code is compiled into the parse tree it is in the INITIAL state
 and when it is being bypassed it is in the NOT_AD_CODE state.
 The conditional compilation handling is implemented using a fixed size
 stack with a maximum depth of 64.
 If there are more than this many levels of nesting of 
\emph on
#ifdef
\emph default
 
\emph on
#endif
\emph default
 blocks then the compilation will fail.
 
\end_layout

\begin_layout Standard
Similarly, the lexer uses a fixed size stack to implement 
\emph on
#include
\emph default
 processing and has a maximum depth of 64.
 If more that 64 nested includes occur then compilation will fail.
 For C++ code 
\emph on
#include
\emph default
 macros are only processed if the include source file is enclosed in quotes.
 If enclosed in < > the include operation is ignored.
 This is a deliberate design feature to allow ADT to ignore system includes
 which in all likelihood, will cause compilation to fail, as ADT only implements
 a restricted subset of the C++ grammar.
\end_layout

\begin_layout Standard
The grammar has one additional non-terminal not part of the language specificati
on, 
\emph on
macro
\emph default
, which is there to be able to compile the macro expansions that are defined
 in the 
\emph on
cpp_macros.txt
\emph default
 file.
 
\end_layout

\begin_layout Standard
Macro expansion is handled through the use of textual code construction
 parsed by the parser to produce replacement code fragments to replace the
 expression being expanded.
\end_layout

\begin_layout Standard
The class 
\emph on
AdtCpp
\emph default
 implements the 
\emph on
AdtCompileBase
\emph default
 specialisation for the support of C++ code and can be found in the 
\emph on
adtutils.hpp
\emph default
 and 
\emph on
adtutils.cpp
\emph default
 source files.
 
\end_layout

\begin_layout Standard
C++ also requires complex handling of symbol tables and symbol scopes.
 This is implemented by the 
\emph on
AdtCppScopeManager
\emph default
 and 
\emph on
AdtCppScope
\emph default
 classes found in the 
\emph on
adtutils.hpp
\emph default
 and 
\emph on
adtutils.cpp
\emph default
 source files.
 
\end_layout

\begin_layout Subsection
Fortran Parser
\end_layout

\begin_layout Standard
The Fortran parser is implemented through the source files 
\emph on
fortran_l.l
\emph default
, 
\emph on
fortran_y.y
\emph default
, 
\emph on
fortran_inc.h
\emph default
, 
\emph on
fortran_l_wrap.c
\emph default
, 
\emph on
fortran_y_wrap.c
\emph default
, 
\emph on
adtfortran.hpp
\emph default
 and 
\emph on
adtfortran.cpp
\emph default
.
 
\end_layout

\begin_layout Standard
The grammar has one additional non-terminal not part of the language specificati
on, 
\emph on
xCallExpand
\emph default
, which was added to be able to compile the CALL expansions that were defined
 in the 
\emph on
fortran_macros.txt
\emph default
 file, which has now been abandoned.
 Instead, the necessary conversions of PUSH and POP calls are now handled
 with a hard coded solution in the ADT source code.
 
\end_layout

\begin_layout Standard
The class 
\emph on
AdtFortran
\emph default
 implements the 
\emph on
AdtCompileBase
\emph default
 specialisation for the support of Fortran code and can be found in the
 
\emph on
adtutils.hpp
\emph default
 and 
\emph on
adtutils.cpp
\emph default
 source files.
 
\end_layout

\begin_layout Subsection
Automatic R Interface Code Infrastructure
\end_layout

\begin_layout Standard
The code responsible for the interpretation of automation commands and generatio
n of R interface and module initialisation code is located in adtautomate.hpp
 and adtautomate.cpp.
 The code is structured around the concept of having to build interfaces
 for classes (
\emph on
AdtAutoClass
\emph default
 class), each class having scalars (
\emph on
AdtAutoScalar
\emph default
 class), arrays (
\emph on
AdtAutoArray
\emph default
 class) and functions (
\emph on
AdtAutoFunction
\emph default
 class).
 
\end_layout

\begin_layout Standard
As much as possible of the code generation code is shared within the 
\emph on
AdtAutoAttribute
\emph default
 and 
\emph on
AdtAutoHelper
\emph default
 classes.
\end_layout

\begin_layout Standard
The interpretation of array size expressions is handled by a special parser,
 the 
\emph on
AdtExpressionCompiler
\emph default
 class, which is implemented in the files 
\emph on
expression_l.l
\emph default
, 
\emph on
expression_y.y
\emph default
, 
\emph on
expression_inc.h
\emph default
, 
\emph on
expression_l_wrap.c
\emph default
, 
\emph on
expression_y_wrap.c
\emph default
, 
\emph on
adtexpression.hpp
\emph default
 and 
\emph on
adtexpression.cpp
\emph default
.
 This allows us to evaluate and check the validity of array size comment
 expressions used in AD code.
 
\end_layout

\begin_layout Chapter
Using ADLib and ADLibPascal
\end_layout

\begin_layout Standard
The ADT package (automatic differentiation via TAPENADE) utility has a companion
 library to implement simplified and efficient array programming.
 The arrays it creates and manages can have up to 10 dimensions with user
 defined starting indices and sizes.
 The arrays are allocated in a single, flat and contiguous block of memory
 to aid in improved computational performance and easier interfacing with
 R arrays.
 
\end_layout

\begin_layout Standard
Arrays can be created independently or managed within an 
\emph on
AdtArrays
\emph default
 class.
 You will typically use the library by declaring your own class which publically
 inherits from 
\emph on
AdtArrays
\emph default
 and then implement the required numerical computations through class methods.
 
\end_layout

\begin_layout Section
Array types
\end_layout

\begin_layout Standard
Multi-dimensional Arrays can be created for any of the (commonly used) intrinsic
 data types within the C/C++ language and most of the intrinsic data types
 in the Pascal language.
 To simplify coding and readability, 
\shape italic
ADLib
\shape default
 and 
\shape italic
ADLibPascal
\shape default
 define aliases for the different size and type arrays.
 The general format of the type name follows the pattern,
\end_layout

\begin_layout SourceCode
ARRAY_{number of dimensions}{type characters}
\end_layout

\begin_layout Standard
The number of dimensions can be between 1 and 10 inclusive and the type
 characters map to intrinsic types as in the following table.
\end_layout

\begin_layout LyX-Code
\begin_inset Tabular
<lyxtabular version="3" rows="13" columns="3">
<features rotate="0" tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C++ type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pascal type
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
type characters
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
bool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
boolean
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
B
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
longbool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
longbool
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
LB
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
shortint
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
C
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
unsigned char
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
byte
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UC
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
integer
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
I
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
unsigned int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UI
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
smallint
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
unsigned short
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
word
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
US
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
longint
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
L
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
unsigned long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
longword
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
UL
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
single
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
F
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\emph on
double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\shape italic
double
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
D
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout LyX-Code

\end_layout

\begin_layout Standard
For example, if we want a 3 dimensional array of doubles then the type would
 be 
\emph on
ARRAY_3D
\emph default
.
 Note that for the Pascal language case unsigned integers are not supported
 because there is no unambiguous type for 32 and 64 bit platforms and therefore
 is not supported.
\end_layout

\begin_layout Section
Creating Arrays
\end_layout

\begin_layout Standard
Arrays can be created in one of two ways, either with explicitely defined
 size/shape using an 
\emph on
AdtArrayPlan
\emph default
 instance (or the complimentary static 
\shape italic
create()
\shape default
 functions), or implicitely by copying the shape of an existing array.
 
\end_layout

\begin_layout Standard
Explicitely specifying the array size and base indices is done through an
 
\emph on
AdtArrayPlan
\emph default
 instance.
 The constructor is overloaded to cater for different dimension arrays and
 follows the generalised form, 
\end_layout

\begin_layout SourceCode
AdtArrayPlan(int nBaseIndex1, int nSize1,
\end_layout

\begin_layout SourceCode
             int nBaseIndex2, int nSize2, 
\end_layout

\begin_layout SourceCode
             int nBaseIndex3, int nSize3, 
\end_layout

\begin_layout SourceCode
              .
       .
           .
 
\end_layout

\begin_layout SourceCode
              .
       .
           .
 
\end_layout

\begin_layout SourceCode
              .
       .
           .
 );
\end_layout

\begin_layout Standard
in the C++ case and,
\end_layout

\begin_layout SourceCode
AdtArrayPlan.create(int nBaseIndex1, int nSize1,
\end_layout

\begin_layout SourceCode
                    int nBaseIndex2, int nSize2, 
\end_layout

\begin_layout SourceCode
                    int nBaseIndex3, int nSize3, 
\end_layout

\begin_layout SourceCode
                     .
       .
           .
 
\end_layout

\begin_layout SourceCode
                     .
       .
           .
 
\end_layout

\begin_layout SourceCode
                     .
       .
           .
 );
\end_layout

\begin_layout Standard
in the Pascal case and supports up to a maximum of 10 dimensions.
 To create an array of that form with that size we call the 
\emph on
create()
\emph default
 method.
 As an example, lets say we want to create  a series of 6 by 4 arrays whose
 indices are one based.
 We create an  
\emph on
AdtArrayPlan
\emph default
 instance that describes the array size with, 
\end_layout

\begin_layout SourceCode
AdtArrayPlan SixByFour(1,6,1,4); 
\end_layout

\begin_layout Standard
in the C++ case and,
\end_layout

\begin_layout SourceCode
Var
\end_layout

\begin_layout SourceCode
  SixByFour :AdtArrayPlan;
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
SixByFour := AdtArrayPlan.create(1,6,1,4); 
\end_layout

\begin_layout Standard
In the Pascal case.
 Then we call the 
\emph on
create
\emph default
 method to make the array with, 
\end_layout

\begin_layout SourceCode
ARRAY_2D Array1 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2D Array2 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2I Array3 = 0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array1);
\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array2);
\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array3);
\end_layout

\begin_layout Standard
In the C++ case and,
\end_layout

\begin_layout SourceCode
Var
\end_layout

\begin_layout SourceCode
  Array1, Array2, Array3 : ARRAY_2D;
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
Array1 := nil;
\end_layout

\begin_layout SourceCode
Array2 := nil;
\end_layout

\begin_layout SourceCode
Array3 := nil;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array1);
\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array2);
\end_layout

\begin_layout SourceCode
SixByFour.create(MemAllocator, Array3);
\end_layout

\begin_layout Standard
In the Pascal case.
 The above code creates three arrays, six by four in size, whose base index
 is one.
 
\emph on
Array1
\emph default
 and 
\emph on
Array2
\emph default
 are arrays of 
\emph on
double's
\emph default
 and 
\emph on
Array3
\emph default
 is an array of
\emph on
 int's
\emph default
.
 
\end_layout

\begin_layout Standard
As an ease of use simplification the library contains overloaded static
 
\shape italic
create()
\shape default
 functions which internally create or access a cached array plan of the
 correct structure and use it to create the array (in the Pascal case we
 use global functions because static methods still require a this pointer
 to be called).
 In short it combines the above two steps into one but caches plans of a
 given structure to avoid creating multiple instances of plans with the
 same dimensions.
 Using this simplification the above arrays can also be created with,
\end_layout

\begin_layout SourceCode
ARRAY_2D Array1 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2D Array2 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2I Array3 = 0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
AdtArrayPlan::create(MemAllocator, Array1, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
AdtArrayPlan::create(MemAllocator, Array2, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
AdtArrayPlan::create(MemAllocator, Array3, 1, 6, 1, 4);
\end_layout

\begin_layout Standard
for the C++ case and,
\end_layout

\begin_layout SourceCode
Array1 := nil;
\end_layout

\begin_layout SourceCode
Array2 := nil;
\end_layout

\begin_layout SourceCode
Array3 := nil;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
AdtArrayPlan_create(MemAllocator, Array1, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
AdtArrayPlan_create(MemAllocator, Array2, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
AdtArrayPlan_create(MemAllocator, Array3, 1, 6, 1, 4);
\end_layout

\begin_layout Standard
for the Pascal case.
 Note that we must supply an instance of the class 
\emph on
AdtMemAllocator
\emph default
 to do the memory allocation for the arrays.
 It is structured this way to facilitate simpler management of arrays and
 their life cycle because if we fail to free the arrays explicitely they
 will be freed when 
\emph on
MemAllocator
\emph default
 is freed.
 Similarly, 
\emph on
MemAllocator
\emph default
 knows all about the arrays it creates so it can then easily create a same
 shaped array from any that it has previously created without the need of
 a plan.
 
\end_layout

\begin_layout Standard
If the allocation code above appears in a method of your class derived from
 
\emph on
AdtArrays
\emph default
 then you will not need to create a 
\emph on
AdtMemAllocator
\emph default
 instance as the 
\emph on
AdtArrays
\emph default
 class has its own instance named 
\emph on
MemAllocator
\emph default
.
 The class 
\emph on
AdtArrays
\emph default
 has simpler equivalent create methods so within that context the above
 example simplifies to,
\end_layout

\begin_layout SourceCode
ARRAY_2D Array1 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2D Array2 = 0;
\end_layout

\begin_layout SourceCode
ARRAY_2I Array3 = 0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
create(Array1, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
create(Array2, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
create(Array3, 1, 6, 1, 4);
\end_layout

\begin_layout Standard
in the C++ case and,
\end_layout

\begin_layout SourceCode
Array1 := nil;
\end_layout

\begin_layout SourceCode
Array2 := nil;
\end_layout

\begin_layout SourceCode
Array3 := nil;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
create(Array1, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
create(Array2, 1, 6, 1, 4);
\end_layout

\begin_layout SourceCode
create(Array3, 1, 6, 1, 4);
\end_layout

\begin_layout Standard
In the Pascal case.
 To create a same shaped array of an existing one we call the static create
 method of 
\emph on
AdtArrayPlan
\emph default
 with a parent array as the third argument in the call.
 Note that the parent array must be of the same type as the copy.
 For example, 
\end_layout

\begin_layout SourceCode
ARRAY_2I    Array4 = 0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
AdtArrayPlan::create(MemAllocator, Array4, Array3);
\end_layout

\begin_layout Standard
in the C++ case will create 
\emph on
Array4
\emph default
 with the same plan as 
\emph on
Array3
\emph default
.
 In the Pascal case the same would be achieved with,
\end_layout

\begin_layout SourceCode
Var
\end_layout

\begin_layout SourceCode
  Array4 : ARRAY_2I;
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
Array4 := nil;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
AdtArrayPlan_create(MemAllocator, Array4, Array3);
\end_layout

\begin_layout Standard
If you are writing code within a method of your derived 
\emph on
AdtArrays
\emph default
 class then we can use the simpler equivalent create method with the call,
 
\end_layout

\begin_layout SourceCode
create(Array4, Array5);
\end_layout

\begin_layout Standard
which applies equally to C++ and Pascal coding.
\end_layout

\begin_layout Section
Mapping Memory as an Array 
\end_layout

\begin_layout Standard
There is one other way we can create arrays and that is creating a map into
 a block of memory to be accessed as an array.
 The typical usage might be that you have a block of memory representing
 a 9 by 8 element matrix that has been passed to you from R and you want
 to index it in a simple fashion (R data structures are all simple blocks
 of memory irrespective of the dimension).
 To do so, we create a plan that fits the structure of the memory being
 passed to us and then pass an extra parameter in the create call, which
 is the pointer to the existing block of memory.
 For example, 
\end_layout

\begin_layout SourceCode
AdtArrayPlan    NineByEigth(1,9,1,8); 
\end_layout

\begin_layout SourceCode
ARRAY_2D        AliasArray = 0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
NineByEight.create(MemAllocator, AliasArray, (void*)pR_ArrayMemory);
\end_layout

\begin_layout Standard
shows the implementation in C++ whilst,
\end_layout

\begin_layout SourceCode
Var
\end_layout

\begin_layout SourceCode
  NineByEigth : AdtArrayPlan;
\end_layout

\begin_layout SourceCode
  AliasArray  : ARRAY_2D;
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
AliasArray  := nil;
\end_layout

\begin_layout SourceCode
NineByEigth := AdtArrayPlan.create(1,9,1,8);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
NineByEight.create(MemAllocator, AliasArray, pchar(pR_ArrayMemory));
\end_layout

\begin_layout Standard
show an equivalent Pascal implementation.
\end_layout

\begin_layout Section
Ragged Arrays
\end_layout

\begin_layout Standard
In certain problems we may have multi-dimensional arrays where many elements
 are zero and need not be stored.
 In such circumstances being able to create ragged arrays may be helpful.
 ADLib allows the outer dimensions of an array to be ragged (vectors with
 different lengths) though creating a plan for such arrays is a little more
 involved.
 
\end_layout

\begin_layout Standard
As an example, lets say we wish to create a two dimensional array which
 comprises two vectors of different lengths, one 5 elements in length and
 the other 25.
 Furthermore we will use zero based indexing.
 The following C++ code fragment creates an array plan matching these requiremen
ts.
 
\end_layout

\begin_layout SourceCode
AdtArrayPlan    Ragged;
\end_layout

\begin_layout SourceCode
int             BaseIndices[2] = {0, 0};
\end_layout

\begin_layout SourceCode
int             Sizes[2] = {5, 25};
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
Ragged.beginRagged(0, 2);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
for (int cn = 0 ; cn < 2 ; cn++)
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  AdtArrayPlan  InnerArrayPlan(BaseIndices[cn], Sizes[cn]);
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
 Ragged.addArrayPlan(InnerArrayPlan, cn);
\end_layout

\begin_layout SourceCode
}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
Ragged.endRagged();
\end_layout

\begin_layout Standard
To make a ragged column we need to call the 
\emph on
beginRagged()
\emph default
 method of the plan we are adding the column to, specifying the base index
 and the size of that column.
 This can be seen from the method prototype, 
\end_layout

\begin_layout SourceCode
bool beginRagged(int nBaseIndex, int nSize);
\end_layout

\begin_layout Standard
in C++ and,
\end_layout

\begin_layout SourceCode
function beginRagged(nBaseIndex,nSize:longint):boolean;
\end_layout

\begin_layout Standard
in Pascal, which returns true if successful.
 After calling 
\emph on
beginRagged()
\emph default
 we need to loop through all the indices of the column and add array plans
 that specify the base index and size of that column entry using the 
\emph on
addArrayPlan()
\emph default
 method whose prototype is, 
\end_layout

\begin_layout SourceCode
bool addArrayPlan(AdtArrayPlan& radtdiffArrayPlan, int nIndex);
\end_layout

\begin_layout Standard
in C++ and,
\end_layout

\begin_layout SourceCode
function addArrayPlan(rAdtdiffArrayPlan : AdtArrayPlan; nIndex : longint):boolea
n;
\end_layout

\begin_layout Standard
in Pascal.
 After specifying plans for all column entries we finalise the plan by calling
 the 
\emph on
endRagged()
\emph default
 method.
 It is essential that 
\emph on
beginRagged()
\emph default
 is always paired with a corresponding 
\emph on
endRagged()
\emph default
 call.
 
\end_layout

\begin_layout Standard
After 
\emph on
endRagged()
\emph default
 has been called arrays conforming to that plan can be created in the manner
 already outlined.
 These ragged arrays will be allocated as one contiguous block of memory
 irrespective of the array shape.
 Similarly, array mapping of existing blocks of memory works in the same
 manner as for conventional arrays.
 
\end_layout

\begin_layout Section
Destroying Arrays
\end_layout

\begin_layout Standard
If you wish to discard an array that is no longer needed and reclaim the
 memory on the heap you can do so as follows.
 Either call, 
\end_layout

\begin_layout SourceCode
AdtArrayPlan::destroy(MemAllocator, Array4); 
\end_layout

\begin_layout Standard
in C++ and,
\end_layout

\begin_layout SourceCode
AdtArrayPlan_destroy(MemAllocator, Array4); 
\end_layout

\begin_layout Standard
in Pascal, or if in the context of an 
\emph on
AdtArrays
\emph default
 derived class method then call,
\end_layout

\begin_layout SourceCode
destroy(Array4);
\end_layout

\begin_layout Standard
in both C++ and Pascal code.
\end_layout

\begin_layout Section
Using the Arrays
\end_layout

\begin_layout Standard
Once created the arrays are simply used in the same manner as conventional
 n-dimensional C arrays or multi-dimensional arrays in Pascal.
 As an example, the C++ code fragment below calculates the average of all
 the elements in our 9 by 8 array passed from R above.
 
\end_layout

\begin_layout SourceCode
int    cn; 
\end_layout

\begin_layout SourceCode
int    cm; 
\end_layout

\begin_layout SourceCode
double dAverage = 0.0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
for (cn = 1 ; cn <= 9 ; cn++) 
\end_layout

\begin_layout SourceCode
{
\end_layout

\begin_layout SourceCode
  for (cm = 1 ; cm <= 8 ; cm++)
\end_layout

\begin_layout SourceCode
  {
\end_layout

\begin_layout SourceCode
    dAverage += AliasArray[cn][cm];
\end_layout

\begin_layout SourceCode
  }
\end_layout

\begin_layout SourceCode
}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
dAverage /= (9 * 8);
\end_layout

\begin_layout Standard
The equivalent in Pascal is,
\end_layout

\begin_layout SourceCode
Var
\end_layout

\begin_layout SourceCode
  cn, cm   : longint;
\end_layout

\begin_layout SourceCode
  dAverage : double;
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
 .
\end_layout

\begin_layout SourceCode
dAverage := 0.0;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
for cn := 1 to 9 do 
\end_layout

\begin_layout SourceCode
begin
\end_layout

\begin_layout SourceCode
  for cm := 1 to 8 do 
\end_layout

\begin_layout SourceCode
  begin
\end_layout

\begin_layout SourceCode
    dAverage := dAverage + AliasArray[cn][cm];
\end_layout

\begin_layout SourceCode
  end;
\end_layout

\begin_layout SourceCode
end;
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout SourceCode
dAverage := dAverage / (9 * 8);
\end_layout

\begin_layout Standard
Note that in convetional C/C++ code, array bases are traditionally always
 zero, whereas the base index in our case is determined by the plan that
 created the array.
 Also note that the base indices you specify when creating the plan can
 be negative.
 This is made possible through pointer offseting and look up tables.
 As operator overloading is not employed there is no indexing overhead and
 no index bounds checking so it is imperative that care is taken not to
 use out of bounds indices.
 
\end_layout

\end_body
\end_document
