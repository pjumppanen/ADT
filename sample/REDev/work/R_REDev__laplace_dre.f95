!        Generated by TAPENADE     (INRIA, Tropics team)
!  Tapenade 3.10 (r5363) -  9 Sep 2014 09:53
!
MODULE COMMON_D
  IMPLICIT NONE
  INTEGER*4, PARAMETER :: dim_stack
  REAL*8 :: choleskymatrixre(nr, nr)
  REAL*8 :: choleskymatrixred1_re(nr, nr)
  REAL*8 :: hessianmatrixre(nr, nr)
  REAL*8 :: hessianmatrixred1_re(nr, nr)
  REAL*8 :: reb1_re(nr)
  REAL*8 :: red2_re(nr)
  INTEGER*4 :: n
  INTEGER*4 :: np
  INTEGER*4 :: nr
  REAL*8 :: par_logk
  REAL*8 :: par_logq
  REAL*8 :: par_logr
  REAL*8 :: par_logr0
  REAL*8 :: par_logtheta
  REAL*8 :: par_u(n)
  REAL*8 :: par_ud1_re(n)
  REAL*8 :: y(n)
  REAL*8 :: yd1_re(n)
  REAL*8 :: par_ub1_re(n)
  REAL*8 :: yb1_re(n)
  REAL*8 :: par_ud2_re(n)
  REAL*8 :: yd2_re(n)
  REAL*8 :: par_ub1_red2_re(n)
  REAL*8 :: par_ub1_red2_red1_re(n)
  REAL*8 :: yb1_red2_re(n)
  REAL*8 :: yb1_red2_red1_re(n)
  REAL*8 :: par_logkd3_par
  REAL*8 :: par_logqd3_par
  REAL*8 :: par_logrd3_par
  REAL*8 :: par_logr0d3_par
  REAL*8 :: par_logthetad3_par
  REAL*8 :: par_ub1_red3_par(n)
  REAL*8 :: yb1_red3_par(n)
  REAL*8 :: par_ud3_par(n)
  REAL*8 :: par_logkb4_par
  REAL*8 :: par_logqb4_par
  REAL*8 :: par_logrb4_par
  REAL*8 :: par_logr0b4_par
  REAL*8 :: par_logthetab4_par
  REAL*8 :: par_ub4_par(n)
  REAL*8 :: par_ud2_red1_re(n)
  REAL*8 :: par_ub1_red1_re(n)
END MODULE COMMON_D

!  Differentiation of r_redev__laplace in forward (tangent) mode:
!   variations   of useful results: r_redev__laplace
!   with respect to varying inputs: re
!   RW status of diff variables: par_ub1_re:(loc) y:(loc) yb1_red2_re:(loc)
!                choleskymatrixre:(loc) hessianmatrixre:(loc) par_ud2_re:(loc)
!                par_ub1_red2_re:(loc) par_u:(loc) re:in r_redev__laplace:out
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__LAPLACE_DRE(re, red1_re, par, r_redev__laplace)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: re(nr)
  REAL*8, INTENT(IN) :: red1_re(nr)
  REAL*8, INTENT(IN) :: par(np)
  USE COMMON_D
  REAL*8 :: h
  REAL*8 :: hd1_re
  INTEGER :: m_pi
  INTRINSIC LOG
  REAL*8 :: R_REDEV__LOGDETHESSIANRE
  REAL*8 :: R_REDEV__LOGDETHESSIANRE_DRE
  REAL*8 :: R_REDEV__LOGLIKELIHOOD
  REAL*8 :: R_REDEV__LOGLIKELIHOOD_DRE
  REAL*8 :: result1
  REAL*8 :: result1d1_re
  REAL*8 :: result2
  REAL*8 :: result2d1_re
  REAL*8 :: r_redev__laplace
  par_ud1_re = 0.0_8
  result1d1_re = R_REDEV__LOGDETHESSIANRE_DRE(re, red1_re, par, result1)
  result2d1_re = R_REDEV__LOGLIKELIHOOD_DRE(re, red1_re, par, result2)
  hd1_re = 0.5*result1d1_re + result2d1_re
  h = (-(nr*LOG(2*m_pi))+result1)*0.5 + result2
  r_redev__laplace_dre = hd1_re
  r_redev__laplace = h
  RETURN
END FUNCTION R_REDEV__LAPLACE_DRE

!  Differentiation of r_redev__logdethessianre in forward (tangent) mode:
!   variations   of useful results: par_u r_redev__logdethessianre
!   with respect to varying inputs: re
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__LOGDETHESSIANRE_DRE(re, red1_re, par, &
& r_redev__logdethessianre)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: re(nr)
  REAL*8, INTENT(IN) :: red1_re(nr)
  REAL*8, INTENT(IN) :: par(np)
  USE COMMON_D
  REAL*8 :: logdet
  REAL*8 :: logdetd1_re
  REAL*8 :: R_REDEV__LOGDETERMINANTFROMCHOL
  REAL*8 :: R_REDEV__LOGDETERMINANTFROMCHOL_DRE
  REAL*8 :: r_redev__logdethessianre
  CALL R_REDEV__HESSIANRE_DRE(re, red1_re, par, hessianmatrixre, &
&                       hessianmatrixred1_re)
  CALL R_REDEV__CHOLESKYDECOMPOSITION_DRE(hessianmatrixre, &
&                                   hessianmatrixred1_re, &
&                                   choleskymatrixre, &
&                                   choleskymatrixred1_re, nr)
  logdetd1_re = R_REDEV__LOGDETERMINANTFROMCHOL_DRE(choleskymatrixre, &
&   choleskymatrixred1_re, nr, logdet)
  r_redev__logdethessianre_dre = logdetd1_re
  r_redev__logdethessianre = logdet
  RETURN
END FUNCTION R_REDEV__LOGDETHESSIANRE_DRE

!  Differentiation of r_redev__hessianre in forward (tangent) mode:
!   variations   of useful results: par_u phessian
!   with respect to varying inputs: re
!  ----------------------------------------------------------------------------
!  ----------------------------------------------------------------------------
SUBROUTINE R_REDEV__HESSIANRE_DRE(re, red1_re, par, phessian, &
& phessiand1_re)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: re(nr)
  REAL*8, INTENT(IN) :: red1_re(nr)
  REAL*8, INTENT(IN) :: par(np)
  REAL*8, INTENT(INOUT) :: phessian(nr, nr)
  REAL*8, INTENT(INOUT) :: phessiand1_re(nr, nr)
  USE COMMON_D
  INTEGER*4 :: cn
  REAL*8 :: loglikelihoodb1_re
  loglikelihoodb1_re = 1.0
  cn = 1
  DO WHILE (cn .LE. nr)
    red2_re(cn) = 0.0
    cn = cn + 1
  END DO
  cn = 1
  par_ud1_re = 0.0_8
  phessiand1_re = 0.0_8
  DO WHILE (cn .LE. nr)
    red2_re(cn) = 1.0
!  Hessian matrix is symmetric and we construct the matrix row by row by
!  taking the tangent derivative of the adjoint derivative in each basis
!  direction. The hessian result goes into an ARRAY_2D but we pass the
!  n'th column to be filled by indexing the array.
    CALL R_REDEV__LOGLIKELIHOOD_BRE_DRE_DRE(re, red1_re, red2_re, &
&                                     reb1_re, phessian(cn), &
&                                     phessiand1_re(cn), par, &
&                                     loglikelihoodb1_re)
    red2_re(cn) = 0.0
    cn = cn + 1
  END DO
END SUBROUTINE R_REDEV__HESSIANRE_DRE

!  Differentiation of r_redev__logdeterminantfromchol in forward (tangent) mode:
!   variations   of useful results: r_redev__logdeterminantfromchol
!   with respect to varying inputs: pl
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__LOGDETERMINANTFROMCHOL_DRE(pl, pld1_re, nsize, &
& r_redev__logdeterminantfromchol)
  IMPLICIT NONE
  INTEGER*4, INTENT(IN) :: nsize
  REAL*8, INTENT(IN) :: pl(nsize, nsize)
  REAL*8, INTENT(IN) :: pld1_re(nsize, nsize)
  USE COMMON_D
! --------------------------------------------------------------------------
!  pL is the cholesky decomposition of A in lower triangular form
! --------------------------------------------------------------------------
  REAL*8 :: dlogdet
  REAL*8 :: dlogdetd1_re
  INTEGER*4 :: ci
  INTRINSIC LOG
  REAL*8 :: r_redev__logdeterminantfromchol
  dlogdet = 0.0
  ci = 1
  dlogdetd1_re = 0.0_8
  DO WHILE (ci .LE. nsize)
    dlogdetd1_re = dlogdetd1_re + pld1_re(ci, ci)/pl(ci, ci)
    dlogdet = dlogdet + LOG(pl(ci, ci))
    ci = ci + 1
  END DO
  dlogdetd1_re = 2.0*dlogdetd1_re
  dlogdet = dlogdet*2.0
  r_redev__logdeterminantfromchol_dre = dlogdetd1_re
  r_redev__logdeterminantfromchol = dlogdet
  RETURN
END FUNCTION R_REDEV__LOGDETERMINANTFROMCHOL_DRE

!  Differentiation of r_redev__loglikelihood in forward (tangent) mode:
!   variations   of useful results: r_redev__loglikelihood
!   with respect to varying inputs: par_u re
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__LOGLIKELIHOOD_DRE(re, red1_re, par, &
& r_redev__loglikelihood)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: re(nr)
  REAL*8, INTENT(IN) :: red1_re(nr)
  REAL*8, INTENT(IN) :: par(np)
  USE COMMON_D
!  Decode parameters     
  REAL*8 :: dlikelihood
  REAL*8 :: dlikelihoodd1_re
  INTEGER*4 :: cn
  INTEGER*4 :: cm
  REAL*8 :: R_REDEV__THETALOGLIKELIHOOD
  REAL*8 :: R_REDEV__THETALOGLIKELIHOOD_DRE
  REAL*8 :: r_redev__loglikelihood
!  Copy over random effects
  cm = 1
  cn = 0
  DO WHILE (cn .LT. nr)
    par_ud1_re(cm) = red1_re(cm)
    par_u(cm) = re(cm)
    cm = cm + 1
    cn = cn + 1
  END DO
!  Copy over parameters
  cm = 1
  par_logr0 = par(cm)
  cm = cm + 1
  par_logtheta = par(cm)
  cm = cm + 1
  par_logk = par(cm)
  cm = cm + 1
  par_logq = par(cm)
  cm = cm + 1
  par_logr = par(cm)
  cm = cm + 1
!  Call likelihood function
  dlikelihoodd1_re = R_REDEV__THETALOGLIKELIHOOD_DRE(par_u, par_ud1_re, &
&   par_logr0, par_logtheta, par_logk, par_logq, par_logr, dlikelihood)
  r_redev__loglikelihood_dre = dlikelihoodd1_re
  r_redev__loglikelihood = dlikelihood
  RETURN
END FUNCTION R_REDEV__LOGLIKELIHOOD_DRE

!  Differentiation of r_redev__thetaloglikelihood in forward (tangent) mode:
!   variations   of useful results: r_redev__thetaloglikelihood
!   with respect to varying inputs: u
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__THETALOGLIKELIHOOD_DRE(u, ud1_re, logr0, &
& logtheta, logk, logq, logr, r_redev__thetaloglikelihood)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: u(n)
  REAL*8, INTENT(IN) :: ud1_re(n)
  REAL*8, INTENT(IN) :: logr0
  REAL*8, INTENT(IN) :: logtheta
  REAL*8, INTENT(IN) :: logk
  REAL*8, INTENT(IN) :: logq
  REAL*8, INTENT(IN) :: logr
  USE COMMON_D
  REAL*8 :: mean
  REAL*8 :: meand1_re
  REAL*8 :: r0
  REAL*8 :: theta
  REAL*8 :: k
  REAL*8 :: q
  REAL*8 :: r
  REAL*8 :: ll
  REAL*8 :: lld1_re
  INTEGER*4 :: cn
  INTRINSIC EXP
  INTRINSIC SQRT
  REAL*8 :: R_REDEV__DLOGNORM
  REAL*8 :: R_REDEV__DLOGNORM_DRE
  REAL*8 :: pwx1
  REAL*8 :: pwx1d1_re
  REAL*8 :: pwr1
  REAL*8 :: pwr1d1_re
  REAL*8 :: result1
  REAL*8 :: result2
  REAL*8 :: result2d1_re
  REAL*8 :: r_redev__thetaloglikelihood
  r0 = EXP(logr0)
  theta = EXP(logtheta)
  k = EXP(logk)
  q = EXP(logq)
  r = EXP(logr)
  ll = 0.0
  cn = 2
  lld1_re = 0.0_8
  DO WHILE (cn .LE. n)
    pwx1d1_re = ud1_re(cn-1)*EXP(u(cn-1))/k
    pwx1 = EXP(u(cn-1))/k
    IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. theta .EQ. INT(theta))) &
&   THEN
      pwr1d1_re = theta*pwx1**(theta-1)*pwx1d1_re
    ELSE IF (pwx1 .EQ. 0.0 .AND. theta .EQ. 1.0) THEN
      pwr1d1_re = pwx1d1_re
    ELSE
      pwr1d1_re = 0.0
    END IF
    pwr1 = pwx1**theta
    meand1_re = ud1_re(cn-1) - r0*pwr1d1_re
    mean = u(cn-1) + r0*(1.0-pwr1)
    result1 = SQRT(q)
    result2d1_re = R_REDEV__DLOGNORM_DRE(u(cn), ud1_re(cn), mean, &
&     meand1_re, result1, result2)
    lld1_re = lld1_re - result2d1_re
    ll = ll - result2
    cn = cn + 1
  END DO
  cn = 1
  DO WHILE (cn .LE. n)
    result1 = SQRT(r)
    yd1_re = 0.0_8
    result2d1_re = R_REDEV__DLOGNORM_DRE(y(cn), yd1_re(cn), u(cn), &
&     ud1_re(cn), result1, result2)
    lld1_re = lld1_re - result2d1_re
    ll = ll - result2
    cn = cn + 1
  END DO
  r_redev__thetaloglikelihood_dre = lld1_re
  r_redev__thetaloglikelihood = ll
  RETURN
END FUNCTION R_REDEV__THETALOGLIKELIHOOD_DRE

!  Differentiation of r_redev__dlognorm in forward (tangent) mode:
!   variations   of useful results: r_redev__dlognorm
!   with respect to varying inputs: x mean
!  ----------------------------------------------------------------------------
REAL*8 FUNCTION R_REDEV__DLOGNORM_DRE(x, xd1_re, mean, meand1_re, sigma&
& , r_redev__dlognorm)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: x
  REAL*8, INTENT(IN) :: xd1_re
  REAL*8, INTENT(IN) :: mean
  REAL*8, INTENT(IN) :: meand1_re
  REAL*8, INTENT(IN) :: sigma
  USE COMMON_D
  REAL*8 :: dvalue
  REAL*8 :: dvalued1_re
  INTRINSIC LOG
  INTEGER :: m_pi
  REAL*8 :: r_redev__dlognorm
  dvalued1_re = -(0.5*2.0*(x-mean)*(xd1_re-meand1_re)/sigma**2)
  dvalue = -LOG(sigma) - 0.5*LOG(2*m_pi) - 0.5*((x-mean)/sigma)**2.0
  r_redev__dlognorm_dre = dvalued1_re
  r_redev__dlognorm = dvalue
  RETURN
END FUNCTION R_REDEV__DLOGNORM_DRE

!  Differentiation of r_redev__choleskydecomposition in forward (tangent) mode:
!   variations   of useful results: pl
!   with respect to varying inputs: pa
! ----------------------------------------------------------------------------
!  ----------------------------------------------------------------------------
SUBROUTINE R_REDEV__CHOLESKYDECOMPOSITION_DRE(pa, pad1_re, pl, pld1_re, &
& nsize)
  IMPLICIT NONE
  INTEGER*4, INTENT(IN) :: nsize
  REAL*8, INTENT(IN) :: pa(nsize, nsize)
  REAL*8, INTENT(IN) :: pad1_re(nsize, nsize)
  REAL*8, INTENT(INOUT) :: pl(nsize, nsize)
  REAL*8, INTENT(INOUT) :: pld1_re(nsize, nsize)
  USE COMMON_D
! --------------------------------------------------------------------------
!  A is symetric positive definite matrix in lower triangular form
!  L is the cholesky decomposition in lower triangular form
! --------------------------------------------------------------------------
  REAL*8 :: sum
  REAL*8 :: sumd1_re
  INTEGER*4 :: ci, cj, ck
  INTRINSIC SQRT
  ci = 1
  pld1_re = 0.0_8
  DO WHILE (ci .LE. nsize)
    sumd1_re = pad1_re(ci, ci)
    sum = pa(ci, ci)
    cj = 1
    DO WHILE (cj .LE. ci - 1)
      sumd1_re = sumd1_re - pld1_re(ci, cj)*pl(ci, cj) - pl(ci, cj)*&
&       pld1_re(ci, cj)
      sum = sum - pl(ci, cj)*pl(ci, cj)
      cj = cj + 1
    END DO
    IF (sum .EQ. 0.0) THEN
      pld1_re(ci, ci) = 0.0_8
    ELSE
      pld1_re(ci, ci) = sumd1_re/(2.0*SQRT(sum))
    END IF
    pl(ci, ci) = SQRT(sum)
    cj = ci + 1
    DO WHILE (cj .LE. nsize)
      sumd1_re = pad1_re(cj, ci)
      sum = pa(cj, ci)
      ck = 1
      DO WHILE (ck .LE. ci - 1)
        sumd1_re = sumd1_re - pld1_re(ci, ck)*pl(cj, ck) - pl(ci, ck)*&
&         pld1_re(cj, ck)
        sum = sum - pl(ci, ck)*pl(cj, ck)
        ck = ck + 1
      END DO
      pld1_re(cj, ci) = (sumd1_re*pl(ci, ci)-sum*pld1_re(ci, ci))/pl(ci&
&       , ci)**2
      pl(cj, ci) = sum/pl(ci, ci)
      cj = cj + 1
    END DO
    ci = ci + 1
  END DO
END SUBROUTINE R_REDEV__CHOLESKYDECOMPOSITION_DRE

!  Differentiation of r_redev__loglikelihood_bre_dre in forward (tangent) mode:
!   variations   of useful results: par_u reb1_red2_re /adstack_r8/[0,inf[
!   with respect to varying inputs: par_u re /adstack_r8/[0,inf[
!  Differentiation of redev__loglikelihood_bre in forward (tangent) mode:
!   variations   of useful results: reb1_re
!   with respect to varying inputs: re
!   RW status of diff variables: par_ub1_re:(loc) y:(loc) yb1_re:(loc)
!                par_u:(loc) reb1_re:out re:in
!  Differentiation of redev__loglikelihood in reverse (adjoint) mode:
!   gradient     of useful results: redev__loglikelihood
!   with respect to varying inputs: re
!   RW status of diff variables: y:(loc) par_u:(loc) redev__loglikelihood:in-killed
!                re:out
!  ----------------------------------------------------------------------------
SUBROUTINE R_REDEV__LOGLIKELIHOOD_BRE_DRE_DRE(re, red1_re, red2_re, &
& reb1_re, reb1_red2_re, reb1_red2_red1_re, par, loglikelihoodb1_re)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: re(nr)
  REAL*8, INTENT(IN) :: red1_re(nr)
  REAL*8, INTENT(IN) :: red2_re(nr)
  REAL*8 :: reb1_re(nr)
  REAL*8 :: reb1_red2_re(nr)
  REAL*8 :: reb1_red2_red1_re(nr)
  REAL*8, INTENT(IN) :: par(np)
  USE COMMON_D
  REAL*8 :: dlikelihoodb1_re
  INTEGER*4 :: cn
  INTEGER*4 :: cm
  INTEGER*4 :: ad_count
  INTEGER*4 :: i
  REAL*8 :: loglikelihoodb1_re
  EXTERNAL PUSHINTEGER4
  EXTERNAL POPINTEGER4
!  Copy over random effects
  cm = 1
  cn = 0
  ad_count = 0
  par_ud2_re = 0.0
  DO WHILE (cn .LT. nr)
    par_ud2_re(cm) = red2_re(cm)
    par_ud1_re(cm) = red1_re(cm)
    par_u(cm) = re(cm)
    CALL PUSHINTEGER4(cm)
    cm = cm + 1
    cn = cn + 1
    ad_count = ad_count + 1
  END DO
  CALL PUSHINTEGER4(ad_count)
!  Copy over parameters
  cm = 1
  par_logr0 = par(cm)
  cm = cm + 1
  par_logtheta = par(cm)
  cm = cm + 1
  par_logk = par(cm)
  cm = cm + 1
  par_logq = par(cm)
  cm = cm + 1
  par_logr = par(cm)
!  Call likelihood function
  dlikelihoodb1_re = loglikelihoodb1_re
  CALL R_REDEV__THETALOGLIKELIHOOD_BRE_DRE_DRE(par_u, par_ud1_re, &
&                                        par_ud2_re, par_ud2_red1_re, &
&                                        par_ub1_re, par_ub1_red1_re, &
&                                        par_ub1_red2_re, &
&                                        par_ub1_red2_red1_re, par_logr0&
&                                        , par_logtheta, par_logk, &
&                                        par_logq, par_logr, &
&                                        dlikelihoodb1_re)
  reb1_re = 0.0
  CALL POPINTEGER4(ad_count)
  reb1_red2_re = 0.0
  reb1_red2_red1_re = 0.0_8
  DO i=1,ad_count
    CALL POPINTEGER4(cm)
    reb1_red2_red1_re(cm) = reb1_red2_red1_re(cm) + par_ub1_red2_red1_re&
&     (cm)
    reb1_red2_re(cm) = reb1_red2_re(cm) + par_ub1_red2_re(cm)
    reb1_re(cm) = reb1_re(cm) + par_ub1_re(cm)
    par_ub1_red2_red1_re(cm) = 0.0_8
    par_ub1_red2_re(cm) = 0.0
    par_ub1_re(cm) = 0.0
  END DO
END SUBROUTINE R_REDEV__LOGLIKELIHOOD_BRE_DRE_DRE

!  Differentiation of r_redev__thetaloglikelihood_bre_dre in forward (tangent) mode:
!   variations   of useful results: ub1_red2_re /adstack_r8/[0,inf[
!   with respect to varying inputs: u /adstack_r8/[0,inf[
!  Differentiation of redev__thetaloglikelihood_bre in forward (tangent) mode:
!   variations   of useful results: ub1_re
!   with respect to varying inputs: u
!  Differentiation of redev__thetaloglikelihood in reverse (adjoint) mode:
!   gradient     of useful results: redev__thetaloglikelihood
!   with respect to varying inputs: u
!  ----------------------------------------------------------------------------
SUBROUTINE R_REDEV__THETALOGLIKELIHOOD_BRE_DRE_DRE(u, ud1_re, ud2_re, &
& ud2_red1_re, ub1_re, ub1_red1_re, ub1_red2_re, ub1_red2_red1_re, logr0&
& , logtheta, logk, logq, logr, thetaloglikelihoodb1_re)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: u(n)
  REAL*8, INTENT(IN) :: ud1_re(n)
  REAL*8, INTENT(IN) :: ud2_re(n)
  REAL*8, INTENT(IN) :: ud2_red1_re(n)
  REAL*8 :: ub1_re(n)
  REAL*8 :: ub1_red1_re(n)
  REAL*8 :: ub1_red2_re(n)
  REAL*8 :: ub1_red2_red1_re(n)
  REAL*8, INTENT(IN) :: logr0
  REAL*8, INTENT(IN) :: logtheta
  REAL*8, INTENT(IN) :: logk
  REAL*8, INTENT(IN) :: logq
  REAL*8, INTENT(IN) :: logr
  USE COMMON_D
  REAL*8 :: mean
  REAL*8 :: meand1_re
  REAL*8 :: meand2_re
  REAL*8 :: meand2_red1_re
  REAL*8 :: meanb1_re
  REAL*8 :: meanb1_red1_re
  REAL*8 :: meanb1_red2_re
  REAL*8 :: meanb1_red2_red1_re
  REAL*8 :: r0
  REAL*8 :: theta
  REAL*8 :: k
  REAL*8 :: q
  REAL*8 :: r
  REAL*8 :: llb1_re
  INTEGER*4 :: cn
  INTRINSIC EXP
  INTRINSIC SQRT
  REAL*8 :: arg1
  REAL*8 :: arg1d1_re
  REAL*8 :: arg1d2_re
  REAL*8 :: arg1d2_red1_re
  REAL*8 :: result1b1_re
  INTEGER*4 :: ad_count
  INTEGER*4 :: i
  INTEGER*4 :: ad_count0
  INTEGER*4 :: i0
  REAL*8 :: thetaloglikelihoodb1_re
  EXTERNAL PUSHREAL8
  EXTERNAL PUSHREAL8_DRE
  EXTERNAL PUSHREAL8_D
  EXTERNAL PUSHINTEGER4
  EXTERNAL POPINTEGER4
  EXTERNAL POPREAL8
  EXTERNAL POPREAL8_DRE
  EXTERNAL POPREAL8_D
  INTRINSIC INT
  REAL*8 :: pwx1
  REAL*8 :: pwx1d1_re
  REAL*8 :: pwx1d2_re
  REAL*8 :: pwx1d2_red1_re
  REAL*8 :: pwr1
  REAL*8 :: pwr1d1_re
  REAL*8 :: pwr1d2_re
  REAL*8 :: pwr1d2_red1_re
  REAL*8 :: pwy1
  REAL*8 :: pwy10
  REAL*8 :: pwr10
  REAL*8 :: pwr10d1_re
  mean = 0
  arg1 = 0
  r0 = EXP(logr0)
  theta = EXP(logtheta)
  k = EXP(logk)
  q = EXP(logq)
  r = EXP(logr)
  cn = 2
  ad_count = 0
  meand2_re = 0.0
  meand2_red1_re = 0.0_8
  meand1_re = 0.0_8
  DO WHILE (cn .LE. n)
    CALL PUSHREAL8_DRE(mean, meand1_re)
    CALL PUSHREAL8_DRE(meand2_re, meand2_red1_re)
    pwx1d2_red1_re = ud2_re(cn-1)*ud1_re(cn-1)*EXP(u(cn-1))/k
    pwx1d2_re = ud2_re(cn-1)*EXP(u(cn-1))/k
    pwx1d1_re = ud1_re(cn-1)*EXP(u(cn-1))/k
    pwx1 = EXP(u(cn-1))/k
    IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. theta .EQ. INT(theta))) &
&   THEN
      pwy10 = theta - 1
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy10 .EQ. INT(pwy10))&
&     ) THEN
        pwr10d1_re = pwy10*pwx1**(pwy10-1)*pwx1d1_re
      ELSE IF (pwx1 .EQ. 0.0 .AND. pwy10 .EQ. 1.0) THEN
        pwr10d1_re = pwx1d1_re
      ELSE
        pwr10d1_re = 0.0
      END IF
      pwr10 = pwx1**pwy10
      pwr1d2_red1_re = theta*(pwr10d1_re*pwx1d2_re+pwr10*pwx1d2_red1_re)
      pwr1d2_re = theta*pwr10*pwx1d2_re
    ELSE IF (pwx1 .EQ. 0.0 .AND. theta .EQ. 1.0) THEN
      pwr1d2_red1_re = pwx1d2_red1_re
      pwr1d2_re = pwx1d2_re
    ELSE
      pwr1d2_re = 0.0
      pwr1d2_red1_re = 0.0_8
    END IF
    IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. theta .EQ. INT(theta))) &
&   THEN
      pwr1d1_re = theta*pwx1**(theta-1)*pwx1d1_re
    ELSE IF (pwx1 .EQ. 0.0 .AND. theta .EQ. 1.0) THEN
      pwr1d1_re = pwx1d1_re
    ELSE
      pwr1d1_re = 0.0
    END IF
    pwr1 = pwx1**theta
    meand2_red1_re = -(r0*pwr1d2_red1_re)
    meand2_re = ud2_re(cn-1) - r0*pwr1d2_re
    meand1_re = ud1_re(cn-1) - r0*pwr1d1_re
    mean = u(cn-1) + r0*(1.0-pwr1)
    arg1d2_re = 0.0
    arg1d1_re = 0.0_8
    CALL PUSHREAL8_DRE(arg1, arg1d1_re)
    arg1d2_red1_re = 0.0_8
    CALL PUSHREAL8_DRE(arg1d2_re, arg1d2_red1_re)
    arg1 = SQRT(q)
    CALL PUSHINTEGER4(cn)
    cn = cn + 1
    ad_count = ad_count + 1
  END DO
  CALL PUSHINTEGER4(ad_count)
  cn = 1
  ad_count0 = 0
  DO WHILE (cn .LE. n)
    arg1d2_re = 0.0
    arg1d1_re = 0.0_8
    CALL PUSHREAL8_DRE(arg1, arg1d1_re)
    arg1d2_red1_re = 0.0_8
    CALL PUSHREAL8_DRE(arg1d2_re, arg1d2_red1_re)
    arg1 = SQRT(r)
    CALL PUSHINTEGER4(cn)
    cn = cn + 1
    ad_count0 = ad_count0 + 1
  END DO
  CALL PUSHINTEGER4(ad_count0)
  llb1_re = thetaloglikelihoodb1_re
  ub1_re = 0.0
  CALL POPINTEGER4(ad_count0)
  ub1_red2_re = 0.0
  arg1d2_re = 0.0
  ub1_red2_red1_re = 0.0_8
  arg1d2_red1_re = 0.0_8
  arg1d1_re = 0.0_8
  DO i0=1,ad_count0
    CALL POPINTEGER4(cn)
    result1b1_re = -llb1_re
    yb1_re = 0.0
    yb1_red2_re = 0.0
    yd2_re = 0.0
    ud2_red1_re = 0.0_8
    yb1_red2_red1_re = 0.0_8
    yd1_re = 0.0_8
    CALL R_REDEV__DLOGNORM_BRE_DRE_DRE(y(cn), yd1_re(cn), yd2_re(cn), &
&                                yb1_re(cn), yb1_red2_re(cn), &
&                                yb1_red2_red1_re(cn), u(cn), ud1_re(cn)&
&                                , ud2_re(cn), ud2_red1_re(cn), ub1_re(&
&                                cn), ub1_red1_re(cn), ub1_red2_re(cn), &
&                                ub1_red2_red1_re(cn), arg1, arg1d1_re, &
&                                arg1d2_re, arg1d2_red1_re, result1b1_re&
&                               )
    CALL POPREAL8_DRE(arg1d2_re, arg1d2_red1_re)
    CALL POPREAL8_DRE(arg1, arg1d1_re)
  END DO
  CALL POPINTEGER4(ad_count)
  DO i=1,ad_count
    CALL POPINTEGER4(cn)
    result1b1_re = -llb1_re
    meanb1_re = 0.0
    meanb1_red2_re = 0.0
    meanb1_red2_red1_re = 0.0_8
    CALL R_REDEV__DLOGNORM_BRE_DRE_DRE(u(cn), ud1_re(cn), ud2_re(cn), &
&                                ub1_re(cn), ub1_red2_re(cn), &
&                                ub1_red2_red1_re(cn), mean, meand1_re, &
&                                meand2_re, meand2_red1_re, meanb1_re, &
&                                meanb1_red1_re, meanb1_red2_re, &
&                                meanb1_red2_red1_re, arg1, arg1d1_re, &
&                                arg1d2_re, arg1d2_red1_re, result1b1_re&
&                               )
    CALL POPREAL8_DRE(arg1d2_re, arg1d2_red1_re)
    CALL POPREAL8_DRE(arg1, arg1d1_re)
    CALL POPREAL8_DRE(meand2_re, meand2_red1_re)
    CALL POPREAL8_DRE(mean, meand1_re)
    IF (EXP(u(cn-1))/k .LE. 0.0 .AND. (theta .EQ. 0.0 .OR. theta .NE. &
&       INT(theta))) THEN
      ub1_red2_red1_re(cn-1) = ub1_red2_red1_re(cn-1) + &
&       meanb1_red2_red1_re
      ub1_red2_re(cn-1) = ub1_red2_re(cn-1) + meanb1_red2_re
      ub1_re(cn-1) = ub1_re(cn-1) + meanb1_re
    ELSE
      pwx1d2_red1_re = ud2_re(cn-1)*ud1_re(cn-1)*EXP(u(cn-1))/k
      pwx1d2_re = ud2_re(cn-1)*EXP(u(cn-1))/k
      pwx1d1_re = ud1_re(cn-1)*EXP(u(cn-1))/k
      pwx1 = EXP(u(cn-1))/k
      pwy1 = theta - 1
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))) &
&     THEN
        pwy10 = pwy1 - 1
        IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy10 .EQ. INT(pwy10&
&           ))) THEN
          pwr10d1_re = pwy10*pwx1**(pwy10-1)*pwx1d1_re
        ELSE IF (pwx1 .EQ. 0.0 .AND. pwy10 .EQ. 1.0) THEN
          pwr10d1_re = pwx1d1_re
        ELSE
          pwr10d1_re = 0.0
        END IF
        pwr10 = pwx1**pwy10
        pwr1d2_red1_re = pwy1*(pwr10d1_re*pwx1d2_re+pwr10*pwx1d2_red1_re&
&         )
        pwr1d2_re = pwy1*pwr10*pwx1d2_re
      ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
        pwr1d2_red1_re = pwx1d2_red1_re
        pwr1d2_re = pwx1d2_re
      ELSE
        pwr1d2_re = 0.0
        pwr1d2_red1_re = 0.0_8
      END IF
      IF (pwx1 .GT. 0.0 .OR. (pwx1 .LT. 0.0 .AND. pwy1 .EQ. INT(pwy1))) &
&     THEN
        pwr1d1_re = pwy1*pwx1**(pwy1-1)*pwx1d1_re
      ELSE IF (pwx1 .EQ. 0.0 .AND. pwy1 .EQ. 1.0) THEN
        pwr1d1_re = pwx1d1_re
      ELSE
        pwr1d1_re = 0.0
      END IF
      pwr1 = pwx1**pwy1
      ub1_red2_red1_re(cn-1) = ub1_red2_red1_re(cn-1) + (1.0-theta*pwr1*&
&       r0*EXP(u(cn-1))/k)*meanb1_red2_red1_re - theta*r0*(pwr1d1_re*EXP&
&       (u(cn-1))+pwr1*ud1_re(cn-1)*EXP(u(cn-1)))*meanb1_red2_re/k - &
&       theta*r0*((pwr1d2_red1_re*EXP(u(cn-1))+pwr1d2_re*ud1_re(cn-1)*&
&       EXP(u(cn-1))+ud2_re(cn-1)*(pwr1d1_re*EXP(u(cn-1))+pwr1*ud1_re(cn&
&       -1)*EXP(u(cn-1))))*meanb1_re+(pwr1d2_re*EXP(u(cn-1))+pwr1*ud2_re&
&       (cn-1)*EXP(u(cn-1)))*meanb1_red1_re)/k
      ub1_red2_re(cn-1) = ub1_red2_re(cn-1) + (1.0-theta*pwr1*r0*EXP(u(&
&       cn-1))/k)*meanb1_red2_re - theta*r0*(pwr1d2_re*EXP(u(cn-1))+pwr1&
&       *ud2_re(cn-1)*EXP(u(cn-1)))*meanb1_re/k
      ub1_re(cn-1) = ub1_re(cn-1) + (1.0-theta*pwr1*r0*EXP(u(cn-1))/k)*&
&       meanb1_re
    END IF
  END DO
END SUBROUTINE R_REDEV__THETALOGLIKELIHOOD_BRE_DRE_DRE

!  Differentiation of r_redev__dlognorm_bre_dre in forward (tangent) mode:
!   variations   of useful results: meanb1_red2_re meanb1_re xb1_red2_re
!   with respect to varying inputs: x sigma meanb1_red2_re sigmad2_re
!                meand2_re xb1_red2_re mean
!  Differentiation of redev__dlognorm_bre in forward (tangent) mode:
!   variations   of useful results: meanb1_re xb1_re
!   with respect to varying inputs: x sigma meanb1_re xb1_re mean
!  Differentiation of redev__dlognorm in reverse (adjoint) mode:
!   gradient     of useful results: x redev__dlognorm mean
!   with respect to varying inputs: x mean
!  ----------------------------------------------------------------------------
SUBROUTINE R_REDEV__DLOGNORM_BRE_DRE_DRE(x, xd1_re, xd2_re, xb1_re, &
& xb1_red2_re, xb1_red2_red1_re, mean, meand1_re, meand2_re, &
& meand2_red1_re, meanb1_re, meanb1_red1_re, meanb1_red2_re, &
& meanb1_red2_red1_re, sigma, sigmad1_re, sigmad2_re, sigmad2_red1_re, &
& dlognormb1_re)
  IMPLICIT NONE
  REAL*8, INTENT(IN) :: x
  REAL*8, INTENT(IN) :: xd1_re
  REAL*8, INTENT(IN) :: xd2_re
  REAL*8 :: xb1_re
  REAL*8 :: xb1_red2_re
  REAL*8 :: xb1_red2_red1_re
  REAL*8, INTENT(IN) :: mean
  REAL*8, INTENT(IN) :: meand1_re
  REAL*8, INTENT(IN) :: meand2_re
  REAL*8, INTENT(IN) :: meand2_red1_re
  REAL*8 :: meanb1_re
  REAL*8 :: meanb1_red1_re
  REAL*8 :: meanb1_red2_re
  REAL*8 :: meanb1_red2_red1_re
  REAL*8, INTENT(IN) :: sigma
  REAL*8, INTENT(IN) :: sigmad1_re
  REAL*8, INTENT(IN) :: sigmad2_re
  REAL*8, INTENT(IN) :: sigmad2_red1_re
  USE COMMON_D
  REAL*8 :: dvalueb1_re
  INTRINSIC LOG
  REAL*8 :: dlognormb1_re
  REAL*8 :: tempb1_re
  REAL*8 :: tempb1_red1_re
  REAL*8 :: tempb1_red2_re
  REAL*8 :: tempb1_red2_red1_re
  dvalueb1_re = dlognormb1_re
  tempb1_red2_red1_re = -(((2.0*0.5*dvalueb1_re*((xd2_re-meand2_re)*2*&
&   sigma*sigmad1_re-meand2_red1_re*sigma**2)-2.0*0.5*dvalueb1_re*2*((&
&   xd1_re-meand1_re)*sigma*sigmad2_re+(x-mean)*(sigmad1_re*sigmad2_re+&
&   sigma*sigmad2_red1_re)))*sigma**4-(2.0*0.5*dvalueb1_re*(xd2_re-&
&   meand2_re)*sigma**2-2.0*(x-mean)*0.5*dvalueb1_re*2*sigma*sigmad2_re)&
&   *2**2*sigma**3*sigmad1_re)/((sigma**2)**2)**2)
  tempb1_red2_re = -((2.0*0.5*dvalueb1_re*(xd2_re-meand2_re)*sigma**2-&
&   2.0*(x-mean)*0.5*dvalueb1_re*2*sigma*sigmad2_re)/(sigma**2)**2)
  tempb1_red1_re = -((2.0*0.5*dvalueb1_re*(xd1_re-meand1_re)*sigma**2-&
&   2.0*(x-mean)*0.5*dvalueb1_re*2*sigma*sigmad1_re)/(sigma**2)**2)
  tempb1_re = -(2.0*(x-mean)*0.5*dvalueb1_re/sigma**2)
  xb1_red2_red1_re = xb1_red2_red1_re + tempb1_red2_red1_re
  xb1_red2_re = xb1_red2_re + tempb1_red2_re
  xb1_re = xb1_re + tempb1_re
  meanb1_red2_red1_re = meanb1_red2_red1_re - tempb1_red2_red1_re
  meanb1_red2_re = meanb1_red2_re - tempb1_red2_re
  meanb1_red1_re = -tempb1_red1_re
  meanb1_re = meanb1_re - tempb1_re
END SUBROUTINE R_REDEV__DLOGNORM_BRE_DRE_DRE

