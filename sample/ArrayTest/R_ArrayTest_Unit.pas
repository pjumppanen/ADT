{$mode delphi}
{$H+}
unit R_ArrayTest_Unit;

interface 
  uses ArrayTest_Unit,adtarray,adtcommon,adtR,Math,Raccess;
  
  type
    R_ArrayTest = class (ArrayTest)
      bstack_1_5{dim_stack} : ARRAY_1I;
      bstack_1_5i : integer;
      
      {$I AT_decl_lib_interface_methods.pas}
      constructor create(arg_ix : longint ; arg_iy : longint ; const arg_A1_I : plongint ; const arg_A1_D : pdouble ; const arg_A2_IA : plongint ; const arg_A2_IB : plongint);overload;
      constructor create(const rCopy : R_ArrayTest);overload;
      destructor destroy();override;
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__sum in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__sum
      //    with respect to varying inputs: x
      //    RW status of diff variables: x:out arraytest__sum:in-killed
      //  ----------------------------------------------------------------------------
      procedure SUM_BX(const x{ix} : ARRAY_1D ; var xb1_x{ix} : ARRAY_1D ; var sumb1_x : double);
      //   Differentiation of global_sum in reverse (adjoint) mode:
      //    gradient     of useful results: x global_sum
      //    with respect to varying inputs: x
      //  ----------------------------------------------------------------------------
      procedure GLOBAL_SUM_BX(const x{ix} : ARRAY_1D ; var xb1_x{ix} : ARRAY_1D ; const nbase : integer ; const ncount : integer ; var global_sumb1_x : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__polysuma in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__polysuma
      //    with respect to varying inputs: x
      //    RW status of diff variables: x:out arraytest__polysuma:in-killed
      //  ----------------------------------------------------------------------------
      procedure POLYSUMA_BX(const x{ix} : ARRAY_1D ; var xb2_x{ix} : ARRAY_1D ; var polysumab2_x : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__polysumb in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__polysumb
      //    with respect to varying inputs: x
      //    RW status of diff variables: x:out arraytest__polysumb:in-killed
      //  ----------------------------------------------------------------------------
      procedure POLYSUMB_BX(const x{ix} : ARRAY_1D ; var xb3_x{ix} : ARRAY_1D ; var polysumbb3_x : double);
      //   Differentiation of arraytest__polyb in reverse (adjoint) mode:
      //    gradient     of useful results: x arraytest__polyb
      //    with respect to varying inputs: x
      //  ----------------------------------------------------------------------------
      procedure POLYB_BX(const x : double ; var xb3_x : double ; var polybb3_x : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__polysumc in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__polysumc
      //    with respect to varying inputs: x
      //    RW status of diff variables: x:out arraytest__polysumc:in-killed
      //  ----------------------------------------------------------------------------
      procedure POLYSUMC_BX(const x{ix} : ARRAY_1D ; var xb4_x{ix} : ARRAY_1D ; var polysumcb4_x : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__iftest in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__iftest
      //    with respect to varying inputs: x
      //    RW status of diff variables: x:out arraytest__iftest:in-killed
      //  ----------------------------------------------------------------------------
      procedure IFTEST_BX(const x : double ; var xb5_x : double ; var iftestb5_x : double);
      //   Differentiation of arraytest__polyb in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__polyb
      //    with respect to varying inputs: x
      //  ----------------------------------------------------------------------------
      procedure POLYB_BX0(const x : double ; var xb5_x : double ; var polybb5_x : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__test_one_if in forward (tangent) mode:
      //    variations   of useful results: arraytest__test_one_if
      //    with respect to varying inputs: v
      //    RW status of diff variables: v:in arraytest__test_one_if:out
      //  ----------------------------------------------------------------------------
      function TEST_ONE_IF_DV(const v : double ; const vd6_v : double ; var test_one_if : double) : double;
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__test_one_if in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__test_one_if
      //    with respect to varying inputs: v
      //    RW status of diff variables: v:out arraytest__test_one_if:in-killed
      //  ----------------------------------------------------------------------------
      procedure TEST_ONE_IF_BV(const v : double ; var vb7_v : double ; var test_one_ifb7_v : double);
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__test_one_if_internal in forward (tangent) mode:
      //    variations   of useful results: arraytest__test_one_if_internal
      //    with respect to varying inputs: v
      //    RW status of diff variables: v:in arraytest__test_one_if_internal:out
      //  ----------------------------------------------------------------------------
      function TEST_ONE_IF_INTERNAL_DV(const v : double ; const vd8_v : double ; var test_one_if_internal : double) : double;
      //         Generated by TAPENADE     (INRIA, Ecuador team)
      //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
      // 
      //   Differentiation of arraytest__test_one_if_internal in reverse (adjoint) mode:
      //    gradient     of useful results: arraytest__test_one_if_internal
      //    with respect to varying inputs: v
      //    RW status of diff variables: v:out arraytest__test_one_if_internal:in-killed
      //  ----------------------------------------------------------------------------
      procedure TEST_ONE_IF_INTERNAL_BV(const v : double ; var vb9_v : double ; var test_one_if_internalb9_v : double);
      function boundsCheckTest(const X{ix} : ARRAY_1D) : double;override;
    end;
  
{$I AT_decl_lib_interface_globals.pas}
{$I AT_decl_lib_interface_constructor.pas}
implementation
  constructor R_ArrayTest.create(arg_ix : longint ; arg_iy : longint ; const arg_A1_I : plongint ; const arg_A1_D : pdouble ; const arg_A2_IA : plongint ; const arg_A2_IB : plongint);
  
  begin
    INHERITED create(arg_ix,arg_iy,arg_A1_I,arg_A1_D,arg_A2_IA,arg_A2_IB);
    createStack(bstack_1_5);
    bstack_1_5i:=0;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  constructor R_ArrayTest.create(const rCopy : R_ArrayTest);
  
  begin
    INHERITED create(rCopy);
    createStack(bstack_1_5);
    bstack_1_5i:=0;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  destructor R_ArrayTest.destroy();
  
  begin
    destroy(bstack_1_5);
    inherited;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__sum in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__sum
  //    with respect to varying inputs: x
  //    RW status of diff variables: x:out arraytest__sum:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.SUM_BX(const x{ix} : ARRAY_1D ; var xb1_x{ix} : ARRAY_1D ; var sumb1_x : double);
  
  var 
    ix_0___ : integer;
    result1b1_x : double;
  
  begin
    ix_0___:=1 - (1);
    
    while add_to(ix_0___,1) <= ix do
    begin
      xb1_x[ix_0___]:=0.0;
    end;
    
    result1b1_x:=sumb1_x;
    xb1_x[male]:=xb1_x[male] + sumb1_x;
    xb1_x[female]:=xb1_x[female] + sumb1_x;
    GLOBAL_SUM_BX(x,xb1_x,1,ix,result1b1_x);
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //   Differentiation of global_sum in reverse (adjoint) mode:
  //    gradient     of useful results: x global_sum
  //    with respect to varying inputs: x
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.GLOBAL_SUM_BX(const x{ix} : ARRAY_1D ; var xb1_x{ix} : ARRAY_1D ; const nbase : integer ; const ncount : integer ; var global_sumb1_x : double);
  
  var 
    cn : integer;
    dsumb1_x : double;
  
  begin
    dsumb1_x:=global_sumb1_x;
    cn:=nbase + ncount - 1 - (-1);
    
    while add_to(cn,-1) >= nbase do
    begin
      xb1_x[cn]:=xb1_x[cn] + dsumb1_x;
    end;
    
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__polysuma in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__polysuma
  //    with respect to varying inputs: x
  //    RW status of diff variables: x:out arraytest__polysuma:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.POLYSUMA_BX(const x{ix} : ARRAY_1D ; var xb2_x{ix} : ARRAY_1D ; var polysumab2_x : double);
  
  var 
    cn : integer;
    dsumb2_x : double;
    ix_0___ : integer;
    result1b2_x : double;
  
  begin
    dsumb2_x:=polysumab2_x;
    ix_0___:=1 - (1);
    
    while add_to(ix_0___,1) <= ix do
    begin
      xb2_x[ix_0___]:=0.0;
    end;
    
    cn:=ix - (-1);
    
    while add_to(cn,-1) >= 1 do
    begin
      result1b2_x:=dsumb2_x;
      xb2_x[cn]:=xb2_x[cn] + (4 * x[cn] - 5) * result1b2_x;
    end;
    
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__polysumb in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__polysumb
  //    with respect to varying inputs: x
  //    RW status of diff variables: x:out arraytest__polysumb:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.POLYSUMB_BX(const x{ix} : ARRAY_1D ; var xb3_x{ix} : ARRAY_1D ; var polysumbb3_x : double);
  
  var 
    cn : integer;
    dsumb3_x : double;
    ix_0___ : integer;
    result1b3_x : double;
  
  begin
    dsumb3_x:=polysumbb3_x;
    ix_0___:=1 - (1);
    
    while add_to(ix_0___,1) <= ix do
    begin
      xb3_x[ix_0___]:=0.0;
    end;
    
    cn:=ix - (-1);
    
    while add_to(cn,-1) >= 1 do
    begin
      result1b3_x:=dsumb3_x;
      POLYB_BX(x[cn],xb3_x[cn],result1b3_x);
    end;
    
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //   Differentiation of arraytest__polyb in reverse (adjoint) mode:
  //    gradient     of useful results: x arraytest__polyb
  //    with respect to varying inputs: x
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.POLYB_BX(const x : double ; var xb3_x : double ; var polybb3_x : double);
  
  begin
    xb3_x:=xb3_x + (pwr(2,2) * x - 5) * polybb3_x;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__polysumc in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__polysumc
  //    with respect to varying inputs: x
  //    RW status of diff variables: x:out arraytest__polysumc:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.POLYSUMC_BX(const x{ix} : ARRAY_1D ; var xb4_x{ix} : ARRAY_1D ; var polysumcb4_x : double);
  
  var 
    cn : integer;
    dsumb4_x : double;
    ix_0___ : integer;
    result1b4_x : double;
  
  begin
    dsumb4_x:=polysumcb4_x;
    ix_0___:=1 - (1);
    
    while add_to(ix_0___,1) <= ix do
    begin
      xb4_x[ix_0___]:=0.0;
    end;
    
    cn:=ix - (-1);
    
    while add_to(cn,-1) >= 1 do
    begin
      result1b4_x:=dsumb4_x;
      xb4_x[cn]:=xb4_x[cn] + (4 * x[cn] - 5) * result1b4_x;
    end;
    
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__iftest in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__iftest
  //    with respect to varying inputs: x
  //    RW status of diff variables: x:out arraytest__iftest:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.IFTEST_BX(const x : double ; var xb5_x : double ; var iftestb5_x : double);
  
  var 
    branch : integer;
    dvalue : double;
    dvalueb5_x : double;
  
  begin
    branch:=0;
    dvalue:=POLYB(x);
    
    if ((dvalue > 0.0)) then 
    begin
      dvalue:=dvalue * 2.0;
      bstack_1_5i:=bstack_1_5i + 1;
      
      if bstack_1_5i > stackSize(bstack_1_5) then 
      begin
        growStack(bstack_1_5,bstack_1_5i);
      end;
      
      bstack_1_5[bstack_1_5i]:=0;
    end
    else 
    begin
      bstack_1_5i:=bstack_1_5i + 1;
      
      if bstack_1_5i > stackSize(bstack_1_5) then 
      begin
        growStack(bstack_1_5,bstack_1_5i);
      end;
      
      bstack_1_5[bstack_1_5i]:=1;
    end;
    
    
    if (true) then 
    begin
      
      if ((dvalue > 1.0)) then 
      begin
        bstack_1_5i:=bstack_1_5i + 1;
        
        if bstack_1_5i > stackSize(bstack_1_5) then 
        begin
          growStack(bstack_1_5,bstack_1_5i);
        end;
        
        bstack_1_5[bstack_1_5i]:=0;
      end
      else 
      begin
        bstack_1_5i:=bstack_1_5i + 1;
        
        if bstack_1_5i > stackSize(bstack_1_5) then 
        begin
          growStack(bstack_1_5,bstack_1_5i);
        end;
        
        bstack_1_5[bstack_1_5i]:=1;
      end;
      
    end
    else 
    begin
      bstack_1_5i:=bstack_1_5i + 1;
      
      if bstack_1_5i > stackSize(bstack_1_5) then 
      begin
        growStack(bstack_1_5,bstack_1_5i);
      end;
      
      bstack_1_5[bstack_1_5i]:=2;
    end;
    
    dvalueb5_x:=iftestb5_x;
    branch:=bstack_1_5[bstack_1_5i];
    bstack_1_5i:=bstack_1_5i - 1;
    
    if ((branch = 0)) then 
    begin
      dvalueb5_x:=1.5 * dvalueb5_x;
    end;
    
    branch:=bstack_1_5[bstack_1_5i];
    bstack_1_5i:=bstack_1_5i - 1;
    
    if ((branch = 0)) then 
    begin
      dvalueb5_x:=2.0 * dvalueb5_x;
    end;
    
    POLYB_BX0(x,xb5_x,dvalueb5_x);
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //   Differentiation of arraytest__polyb in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__polyb
  //    with respect to varying inputs: x
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.POLYB_BX0(const x : double ; var xb5_x : double ; var polybb5_x : double);
  
  begin
    xb5_x:=(pwr(2,2) * x - 5) * polybb5_x;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__test_one_if in forward (tangent) mode:
  //    variations   of useful results: arraytest__test_one_if
  //    with respect to varying inputs: v
  //    RW status of diff variables: v:in arraytest__test_one_if:out
  //  ----------------------------------------------------------------------------
  function R_ArrayTest.TEST_ONE_IF_DV(const v : double ; const vd6_v : double ; var test_one_if : double) : double;
  
  var 
    result1 : integer;
    result2 : integer;
  
  begin
    result1:=T_ONE_IF((v > 0.0));
    result2:=T_ONE_IF((v > 30.0));
    result:=(result1 - result2) * 5 * pwr(v,4) * vd6_v;
    test_one_if:=(result1 - result2) * pwr(v,5);
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__test_one_if in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__test_one_if
  //    with respect to varying inputs: v
  //    RW status of diff variables: v:out arraytest__test_one_if:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.TEST_ONE_IF_BV(const v : double ; var vb7_v : double ; var test_one_ifb7_v : double);
  
  var 
    result1 : integer;
    result2 : integer;
  
  begin
    result1:=T_ONE_IF((v > 0.0));
    result2:=T_ONE_IF((v > 30.0));
    vb7_v:=(result1 - result2) * 5 * pwr(v,4) * test_one_ifb7_v;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__test_one_if_internal in forward (tangent) mode:
  //    variations   of useful results: arraytest__test_one_if_internal
  //    with respect to varying inputs: v
  //    RW status of diff variables: v:in arraytest__test_one_if_internal:out
  //  ----------------------------------------------------------------------------
  function R_ArrayTest.TEST_ONE_IF_INTERNAL_DV(const v : double ; const vd8_v : double ; var test_one_if_internal : double) : double;
  
  var 
    result1 : integer;
    result2 : integer;
  
  begin
    result1:=ONE_IF((v > 0.0));
    result2:=ONE_IF((v > 30.0));
    result:=(result1 - result2) * 5 * pwr(v,4) * vd8_v;
    test_one_if_internal:=(result1 - result2) * pwr(v,5);
  end;
  
  { ---------------------------------------------------------------------------- }
  
  //         Generated by TAPENADE     (INRIA, Ecuador team)
  //   Tapenade 3.12 (r6213) -  6 Dec 2016 14:28
  // 
  //   Differentiation of arraytest__test_one_if_internal in reverse (adjoint) mode:
  //    gradient     of useful results: arraytest__test_one_if_internal
  //    with respect to varying inputs: v
  //    RW status of diff variables: v:out arraytest__test_one_if_internal:in-killed
  //  ----------------------------------------------------------------------------
  procedure R_ArrayTest.TEST_ONE_IF_INTERNAL_BV(const v : double ; var vb9_v : double ; var test_one_if_internalb9_v : double);
  
  var 
    result1 : integer;
    result2 : integer;
  
  begin
    result1:=ONE_IF((v > 0.0));
    result2:=ONE_IF((v > 30.0));
    vb9_v:=(result1 - result2) * 5 * pwr(v,4) * test_one_if_internalb9_v;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  function R_ArrayTest.boundsCheckTest(const X{ix} : ARRAY_1D) : double;
  
  var 
    CHECK_X_1 : CHECK_CONTEXT;
    cn : integer;
    dSum : double;
  
  begin
    CHECK_X_1:=nil ;
    dSum:=0.0;
    cn:=1 - (1);
    
    while add_to(cn,1) <= ix + 5 do
    begin
      check1(CHECK_X_1,X,'X',{$I %FILE%},{$I %LINE%},false,cn,'cn');
      dSum:=dSum + X[cn];
    end;
    
    result:=dSum;
  end;
  
  { ---------------------------------------------------------------------------- }
  
  
  {$I AT_impl_lib_interface_methods.pas}
{$I AT_impl_lib_interface_globals.pas}
{$I AT_impl_lib_interface_constructor.pas}
end.
